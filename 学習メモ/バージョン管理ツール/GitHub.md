- **_GitHub でできる事_**
  - コードの共有
    - Git で管理しているソースコードをわかりやすく共有できるもの
      - オンライン上に公開する事ができる
  - コードレビューをプロジェクトメンバーへ依頼する
    - 開発したソースコードを大元に反映させる
      - プルリクエスト
        - コードレビューを便利に要求できる
  - OSS に参加する事ができる
    - Ruby のライブラリ
    - Rails のライブラリ
      - 全世界のソースコードをいつでも読むことができる
        - 新たな機能などもプルリクエストする事ができる
- **GitHub のチーム開発**

  - ローカルで Branch を作って GitHub にプッシュする

    - Branch

      - 分岐して開発する方法

        - コミット 1

          ↓

        - コミット 2
          - Branch
            - main
            - feacher

        ↓

        - コミット 3（main）
        - コミット 3 ｀(feacher)

      - Branch の作成
        - git branch ブランチ名
      - Branch の確認
        - git branch
      - リモートリポジトリの Branch 内容も確認する
        - git branch -a

    - Branch を切り替える
      - HEAD を切り替えて自分がいる Branch を切り替える
        - Swith をする
          - git switch ブランチ名
      - Branch を新規作成して切り替える
        - git switch -c ブランチ名
    - 変更をマージする

      - コミット 2

        - Branch
          - main
          - feacher

        ↓

      - コミット 3（main）
      - コミット 3 ｀(feacher)

        merge

        ↓

      - コミット 4（main）
        - Branch が分かれているものを一つにまとめる
          - git merge ブランチ名
        - GitHub 上にある Branch をローカルの Branch に merge する場合
          - git merge リモート名/ブランチ名

    - コンフリクト
      - コンフリクトを解消する
        - 作成されたファイルを修正する
          - 求めている状態に戻す
            - vi ファイル名
        - <<< === >>> を削除する

  - GitHub でプッシュ、プルをする
    - GitHub の登録
    - リポジトリの作成
      - ローカルのリポジトリと同じ内容のリポジトリを作成する
    - リモートリポジトリを追加する
      - git remote add origin(リモート名) URL(リポジトリ URL)
    - リモートリポジトリにプッシュする
      - git push origin main
    - リモートリポジトリをプルする（リモートをローカルに引く）
      - ローカルのリポジトリに反映させた上でワークツリーにも変更を反映させる事ができる
        - git pull リモート名 ブランチ名
          - git pull と省略も可能
    - ローカルのリポジトリにリモートリポジトリの内容を反映する
      - fetch
        - git fetch リモート名
      - ワークツリーにも取得したい場合には merge も行う必要がある
    - pull と fetch の使い分け
      - コンフトリクトが起きそうな場合には fetch+merge を行う
        - ワークツリーでの変更内容とリモートの変更内容が同じだと修正が面倒になってしまう
      - main ブランチにいる時には pull を使う
      - 派生させた Branch にいる時には fetch ＋ merge をして変更内容などを合体させるとコンフトリクトが起きずらい
  - プルリクエストをする
    - チーム開発において高品質なコードを保つ
      - コードレビューを挟んでから変更を反映させる
    - プルリクエストの手順 => branch を切る
      - ローカルの状態を main ブランチを最新の状態にする(pull or fetch+merge)
      - そこから Branch を作成する
        - 作成した Branch でファイルの変更などを行いコミットする
      - GitHub へプッシュする
      - プルリクエストする
      - 開発チームメンバーはコードレビューする
      - マージする
  - コードレビューが終わったら GitHub に変更を反映する
    - Branch を削除する　 delate branch

- 直マージしない　＝＞　 PR を挟んでマージする
  - ソースツリーで Branch を作る
    - main から Branch を切る
      - main の最新から切る
        - ローカルとリモートに差分がある
        - マージするとリモートが更新される
        - リモートとローカルに差分が生まれる
        - この差分があるまま Branch を切るとコンフトリクトが起きる
        - リモートからローカルにプルして最新の状態にしてから Branch を切るようにする
  - コミットしてプッシュする
  - プルリクエストをする
    - コードの差分を確認する
    - 大丈夫であれば confirm pull リクをする
  - マージする
  - Branch を削除
    - 機能毎に Branch を削除する
      - feature/機能名
        - 例：
          - 一覧機能　＝＞　 feature/tasks-index 　 ⇦ ケバブケースで書く
- **_github の仕様_**
  - github とは
    - 分散型のバージョン管理システム
      - 他の例として
        - CVS,Subversion などがある
          - Concurrent Versions System
            - バージョン管理システム
    - 変更履歴の把握
      - 例えば、、、、
        - github を使用していない場合
          - 自分が行った変更を元に戻したいと思い ⌘ ＋ Z を押すが Undo できない
          - 同じ階層にファイルが錯綜する
            - ファイルの新旧の把握ができない
    - バックアップ
    - 複数人での作業
  - github で管理しているもの
    - 管理にはリポジトリという歴史、履歴の保管庫がある
      - リポジトリの管理方法
        - 集中バージョン管理システム
          - 集中バージョンでは変更が全ての人に影響する
          - リポジトリにアクセスできない状態だと作業が止まる
        - 分散バージョン管理システム
          - git
            - 自分専用のリポジトリを作成できる
            - ローカル環境で作業が可能
  - github を活用する対象の職種
    - Git はプログラマーの物か？
      - Git で小説を書く人もいる
        - 使い方次第で可能性がある
  - github を使う開発単位
    - Git はチーム開発のもの？
      - チーム
      - 個人
        - どちらも大丈夫
  - github の UI
    - Git の画面は全ては黒いの？
      - ソフトもあるため変更可能
  - github の内部構造（粒度を高く大雑把に）
    - Git の階層構造
      - ローカルリポジトリ
        - 履歴が溜まる場所
      - インデックス
        - 準備場所
      - ワークツリー
        - 作業フォルダー
      - Git は３層構造になっている
        - ワークツリーからインデックスへステージングする
        - インデックスでローカルリポジトリへコミットする
          - ステージング
            - リポジトリは倉庫と考えられる
              - 倉庫に箱の単位で格納する
                - 目的に分けて箱を分ける
        - 箱に分ける基準
          - タスク単位で分ける
            - トップページを追加した
            - 画像の変更をした
            - ナビゲーションにボタンを追加した
              - 元に戻すことを考える
        - コミット履歴はハッシュで履歴の順番毎に保存される
          - 適切なタイミングでリリースする
            - リリースするタイミングでタグをつける事ができる
              - タグ
                - 英数字
                - バージョン番号
        - DropBox などとの違い
          - バックアップが日付単位、ファイル単位
            - Git は区切りをタグを使って管理できる
  - Branch（枝）
    - 普段使うのはマスターブランチ
      - 必要に応じてブランチに分ける事が可能になる
        - ブランチを取り込む、合流する事も可能
          - どこのタイミングからでもブランチは作成可能
    - ブランチするタイミング
      - リリースまでに時間がかかる
      - 実験的な作業（あとからなかった事にできる）
      - 全体に大きな影響を与える可能性がある作業
    - ブランチには命名する事ができる
      - デフォルト
        - master
      - 作業中のブランチ
        - HEAD
      - 適宜ブランチの切り替え（git checkaout）を行う
        - git switch
        - git restore
  - 増えた Branch の扱い(ブランチの統合)
    - merge
      - Branch での変更を変更タグを残したままで合流する
        - 履歴として変更内容を残す必要がある大きな変更
      - 種類：
        - fast-forward
          - 枝分かれもとに変更がない
            - マージコミットを残さずにそのままくっつける事が可能
              - —no-off オプションでマージコミットを作成する事も可能になる
        - non-fast-forward
          - 枝分かれもとに変更がある
    - rebase
      - Branch を合流して変更タグも残さない
        - 変更履歴を残す必要がない変更
    - cherry-pick
      - 他の Branch から変更をもらう
        - いいとこ取り
          - Branch 同士のやり取り
  - ローカルの状態確認(git status)
    - Git 管理下にはいない
    - 編集済み
    - ステージ済み
  - リモート・ローカル間のやり取り
    - ワークツリーから変更内容をステージ
    - ローカルリポジトリからリモートリポジトリへプッシュ
    - プッシュされた内容をローカルリポジトリへプル
      - プル
        - fetch+merge
  - チーム開発で Git を使う
    - Git は４階層とも考えられる
      - ３階層に加えてリモートリポジトリもある
        - ローカル環境へリモートリポジトリをクローンする
        - ローカル環境からリモートリポジトリへ pull,push する
      - リモートリポジトリ
        - サーバーコンピュータの準備
        - Git ホスティングを借りる
          - Git ホスティング
        - リポジトリをみんなで共有できる
        - 他の人の変更を取り込む、自分の変更をアップできる
        - Web サーバーへ Git を通じてアップロードもできる
    - Git は分散型バージョン管理
      - 各個人、データを保存しデータの保管場所を所持している
      - 共有したいブランチやタグを選んでプッシュする
        - 副作用：
          - お互いに上書きが起きる可能性
            - 自分の変更 → 新しい
            - 相手の変更 → 新しい
              - 手動マージをする
                ```html
                h1 { <<<<<<< HEAD color: red; ====== color: blue; >>>>>>> issue3
                }
                ```
  - コマンドラインを使う
    - 基本的な機能はコマンドラインで全て完結する事ができる
      ![image.png](attachment:ae1a5497-f378-4607-9ed8-d393b4b27d68:image.png)
    - コミット履歴も見れる
      ![スクリーンショット 2025-02-27 3.02.29.png](attachment:1acacc74-dbb0-40f6-a846-49836479d649:スクリーンショット_2025-02-27_3.02.29.png)
    - コマンドラインも使用できるようにしながら GUI も使いながらやる事が望ましい
      - コマンドを怖がらず、こだわらず
        - 普段のコミット、ブランチ作成くらいはブランチで
        - コミット履歴を見る、マージやコントリクトなどは GUI を活用する
  - その他
    - git-flow
      - Git を使ってソフトウェア開発モデル
        - 専用のツール（コマンドライン）もある
  - github リポジトリの扱い方（クローンの手順）
    - クローンの手順
      - ターミナルでファイルを保存する場所に入る
      - ls
      - cd ディレクトリ名
      - git clone クローンするリポジトリの URL or SSH など
      - VS コード新しく開いて、ディレクトリを開く
    - GitHub コミットメッセージ
      - 基本的に敬語不要
        - 冗長であるから
      - 必要な情報のみをコミットメッセージに記載する
    - GitHub のコミットメッセージ変更可能？
      - 変更可能だけど一旦保留
        - 過去の変更履歴を消して上書きする
    - コミットメッセージを適切に書かないと複数同じコミットメッセージができてしまう
    - コミットメッセージ - メッセージの内容 - 長すぎずに一文で変更内容がわかるように - そもそも、コードやページの抽象を理解できない場合に適切なコミットメッセージが書けない - 詳細（現象）→ 現象に至るまでの過程を抽象化して理解できるように
      **まとめ**
  - やる事
    - まずは SourceTree をインストール
    - 1 人でテストプロジェクトで試す
    - 1 人で実践投下
    - チームで利用する
- git を使う際におきがちな事象
  - 余計なコミット
    - gitignore ファイルを作成する
      - 記載したファイルが git の対象から外れる
  - git と github の混同
    - git
      - 分散型のバージョン管理システム
    - github
      - git を使ったソフトウェア開発プロジェクトのためのウェブサービス
  - コンフリクト恐怖症
    - <<<<<<<<<<<
      > > > > > > > > > > >
          - 概要する場所には記載が必ずあるはずなので探す
              - エディターによっては表示で教えてくれる
- 間違えが起こった？と不安になる時の対処法

  - 予期せぬコンフリクトが起こった場合
    - 直前のマージを取り消す
      git merge —abort
    - 慌ててミスするのであればマージ前に戻す
  - 間違ったコミット
    - コミットを打ち消した事を記録する
      git revert
    - コミットの完全抹消
      git reset - push の後の reset は危険なので注意が必要
    - 直前のコミットを編集する
      - git commit —amend
  - 間違った add/編集
    - どのようにしたら戻せるか？確認
      - git status
  - データが消えてしまった後の最後の望み
    - git reflog

- 実際に Git と GitHub を使ってみる
  - 用語まとめ
    - ローカルリポジトリを作成する
      - git init
    - ローカルリポジトリに変更点を追加する（インデックスに追加する）
      - git add ファイル名
    - ローカルリポジトリにインデックスに追加したファイルを登録する
      - git commit -m “コミット内容”
    - 追加したインデックスを GitHub に作成する
      - git remote add origin リポジトリの URL
    - ローカルリポジトリのファイルを GitHub のリポジトリに送信する
      - git push origin ブランチ名
  - コマンドまとめ
    - 新しいブランチを作る
      - git branch ブランチ名
    - 今あるブランチを確認する
      - git branch
    - ブランチの移動
      - git checkout ブランチ名
    - ブランチのマージ
      - 結合したい branch に checkout で移動してから
      - git merge 取り込むブランチ名
- git の学習

  - 公式のドキュメント
    - https://git-scm.com/book/ja/v2
  - 実際に Git を使ってみる続き
    - https://note.com/nahito/n/nded6e4dd7382

- Git と Github に関して復習する
  - Git
    - バージョン管理のための CLI
  - Github
    - Git で管理しているソースコードをわかりやすくオンラインで共有する事ができるプラットフォーム

**ユースケース**

- 参考記事

  - [GitHub のマージは基本スカッシュでいいと考えている](https://zenn.dev/kyoten/articles/b9c53f63d8da4d)（Zenn）

- 課題

  - マージ方式について
    - 基本的に多くの運用方法において、「とりあえずデフォルトでマージしているという運用」が多く存在しているという事
      - CI/CD の条件に応じて必要な条件は変わってくる事が前提にあるが、実務的な運用において 1 つの方法を提示する

- 実務例：基本的にスカッシュマージ、例外的に通常マージ
  - スカッシュマージ
    - フィーチャー Branch での作業を 1 つのコミットに圧縮して Main や Develop にコミットする方法
      - Main や Develop のコミット履歴が綺麗になる
        - 後から見た時に文脈等を把握できていない状況でも履歴が読みやすくなる
  - 通常マージ
    - スカッシュマージは 1 つのコミットに圧縮したのに対して、フィーチャー Branch でのコミット履歴を全て保持した状態でマージする方法
      - マージコミットが作成されるため、Main や Develop と Branch との関係性がわかりやすくなる
        - 文脈や Branch との関係姓をある程度理解できている人であれば、Branch 単位で理解可能
  - スカッシュマージと通常マージの違い

【 Squash and merge 】<=スカッシュマージ
feature ┬─ fix
└─ fix typo
↓
main ────●── (1 コミット)

【 Create a merge commit 】<=通常マージ
feature ┬─ fix
└─ fix typo
↓ ✕ (ブランチ構造を残す)
main ────●───○── (マージコミット)
└──┘

【 Rebase and merge 】
feature ┬─ fix'
└─ fix typo' (⚠️ 　コミットを書き直す)
↓
main ────●──●── (リニアだが危険)

- 基本的にスカッシュをマージ戦略として採用する理由

  - 理由
    - 将来の読み手を想定した時に有利になると考えるため
  - なぜか？
    - 基本的にマージするタイミング(レビュワーがレビューするタイミング)は意図的なタイミングであり、何らかの変更が起こるタイミングだから
      - スカッシュマージにおいて、その変更の意図をコミットに表す事で変更の単位で区切る事が出来て、整理が容易
    - 小規模、短命な PR においては、マージの利点が少ない

- マージ運用ルール（推奨）

  - 基本方針
    - デフォルトのマージスタイルは **Squash and merge** にする
    - PR テンプレートの活用
      - PR の説明欄に「通常マージを希望する理由」を明記させるテンプレートを用意する
    - レビュワーの判断基準
      - 「この PR は 1 コミットにまとまっていても意味が失われないか」を基準に判断する
  - Create a merge commit（通常マージ）を許可する条件
    - 各コミットが独立したリバータブルな単位である場合
    - 大規模かつ長期間の並行開発ブランチの場合
    - リリースブランチの統合時
  - 補足
    - 必要に応じて git の運用ドキュメントで revert や cherry-pick のベストプラクティスを追記する

- 開発ブランチ運用例（推奨パターン）

  - feature ブランチ → develop
    - 各 PR は **Squash and merge** を基本とする
    - 理由：細かいコミット履歴を整理し、develop の履歴を読みやすく保つため
  - develop → main
    - **Create a merge commit** を用いてマージする
    - マージコミットにタグ（例: v1.2.3）を付与する
    - 理由：
      - develop へのスカッシュで履歴を整理しつつ、develop から main への通常マージで「いつ main に入ったか」を履歴として残せる
      - タグ付けやリリース管理が容易になる
      - マージ時刻とリリースを明確化できる

- 学習ソース
  - https://qiita.com/nnahito/items/565f8755e70c51532459
