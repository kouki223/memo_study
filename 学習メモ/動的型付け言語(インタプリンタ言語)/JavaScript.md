- 学習ソース
    - progate
        - https://prog-8.com/courses/es6
    - JavaScript primer
        https://ja.m.wikibooks.org/wiki/JavaScript/void#:~:text=void%20%E3%81%AF%E3%80%81JavaScript%20%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89,%E6%89%8B%E6%AE%B5%E3%81%A8%E3%81%97%E3%81%A6%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82
- ***JavaScripの概要***
    - Java Scriptって何？
        - 主にWebブラウザの中で動くプログラミング言語
            - 動的型付け言語(インタプリンタ言語)である
        - Webアプリケーションにおいてクライアントサイドでもサーバーサイドでも動作する言語
            - 動的なページを作るのに必須になっている
                - 操作に応じて表示が変わる
                - データの取得
                    - Webサーバーと通信を行う
                - データの更新
            - htmlとcssのみではできない事をしている
        - 現在のWebサイトには欠かせない存在になっている
            - Webアプリケーション　＝＞　Webアプリケーションのように動くWebサイト
        - JavaScriptはNode.jsでも使用されている
            - デスクトップアプリ
            - スマートフォンアプリ
            - IoTデバイス
                - などでも使用することができている
        - 元々、Netscape Navigatorというブラウザ向けに開発された言語
            - 影響を受けた言語
                - C
                - Java
                - Self
                - Scheme
            - 大部分がオブジェクトで構成される
                - オブジェクト同士の関係性で成り立っている
                    - オブジェクトの種類
                        - ECMAScriptの仕様で定められたオブジェクト
                        - 実行環境が定義したオブジェクト
                        - ユーザー（自分）が定義したオブジェクト
    - ランタイムシステム
        - Node.js
            - V8エンジンを使ってJavaScriptをサーバーサイドでも使えるようにしたもの
                - APIやライブラリを提供する 
        - DENO
            - JavaScriptとTypeScriptの実行環境を提供する
        - BUN
            - JavaScriptCoreエンジンを使用する
    - ランタイムエンジン
        - V8エンジン　＝＞　Googleが開発　＝＞　高速な実行環境
        - SpiderMonkey
        - JavaScriptCore
        - Chakra
        - Nashorn
    - ECMAScript
        - 仕様
            - どの実行環境でも共有の環境
                - JavaScriptはこのECMAScriptnによって仕様が決まっている
                    - JS・TSが準拠する仕様
        - JSとECMAScriptの関係
            - 仕様を定義する
                - 仕様　＝＞　決まりごと
                    - ブラウザがJSを読み込んだ時にどのように解釈するのか？
                        - 処理がどのように動くのか？という事を定義する
            - 歴史
                - JSを標準化するべくECMAScriptが策定された
                    - JSはNetscape社が開発した言語
                        - Netscape社はJSを標準化するために国際規格策定団体Ecmaインターナショナルに依頼する
                            - その結果
                                - Ecmaによって標準化されたJavaScriptはECMAScriptと呼ばれる事になっている
            - JSが従うべき仕様
                - ECMAScriptがJSがどのように振る舞うかを定義している
                    - JSの実装　＝＞　ECMAScriptの実装と呼ばれる事もある
            - 命名由来
                - 競争関係だったNetscape社とMicrosoft社
                    - ECMAScriptが合意できる妥協案だった説
                        - Netscape社 => JavaScript
                        - Microsoft社 => JScript
                - JavaScriptという言葉が商標だった事
                    - JavaScriptは当時Sunが所有する商標だった
                        - 現在はorakle社が保有
        - JavaScriptの仕様は毎年更新される
            - ECMAScriptは毎年更新される
                - JavaScriptには新しい構文や機能が増え続ける
                    - ECMAScriptは後方互換性に優れる
                        - 学びは無駄にならない
        - 仕様改訂のステップ
            - ステージ	条件
                - 0 **Strawperson**	なし
                - 1 **Proposal**	チャンピオン(委員会の改定推進パートナー)が決まっている
                    - 課題と解決策を説明したリポジトリが公開されている
                        - デモがあるとよい
                - 2 **Draft**	ECMAScriptの仕様記述言語で主要な部分の仕様が書かれていること
                - 3 **Candidate**	完全な仕様書があること。レビュアとECMAScript編集者の署名があること
                - 4 **Finished**	2つ以上のJSエンジンに実装が存在していること。
                    - ECMAScriptへプルリクエストが送信されている
                        - ECMAScript編集者に承認されていること
        - ECMAScriptとブラウザの関係
            - ECMAScripが決めるクライアントサイドのJSは部分的
                - ECMSScriptは主に
                    - 言語の文法、構文の解釈方法、コアのAPIなど言語の中核部分を決める
                        - 関数宣言の書き方はこういう文法になる
                        - 変数が宣言されたとき、JavaScriptエンジンはこういう動作になる
                        - StringやArrayオブジェクトにはこういうメソッドがある
            - JSにおけるブラウザ仕様を決める団体 => 標準化団体WHATWG
                - HTML Living Standard
                    - windowオブジェクト
                    - HTMLDivElement
                    - ローカルストレージなどのAPI
            - ブラウザ内部は様々な部品で分ける事ができる
                - レンダリングエンジン
                    - JSエンジンを組み込んだブラウザの表示機能を担うモジュール
                        - JSのみならずHTMLやCSSも解釈して総合的に画面表示をする
                            - Blink
                                - V8エンジンをJSエンジンに採用
                            - Gecko
                            - WebKit
                - JavaScriptエンジン
                    - ECMAScriptを実装したモジュール
                        - V8
                        - SpiderMonkey
                        - JavaScriptCore
                - レンダリングエンジンは変更される事や環境に応じて変わる
                    - iosのエンジンはWebKitと独占的に利用を許されている
                        - 同じサービスでも環境に応じて変化する
                - エンジニアはエンジンについて理解する事が重要
                    - 普段、コードを書くエンジニアはエンジンについて理解する事が重要である
                        - エンジンについて理解する事　＝＞　実行環境ついて理解する事
                            - テストなど、バグに関して基本的にはECMAScriptに準拠するエンジンでも少しの違いなどが出てくる可能性がある
                ![alt text](https://typescriptbook.jp/img/overview/ecmascript/browser-rendering-engine-javascript-engine-ecmascript-relations.svg)
        - JSにおける仕様決定の棲み分け
            - モジュール
                - ECMAScript
                    - importやexportの構文や、モジュール内部の仕様
                - HTML Living Standard
                    - import "指定子"
    - Ecmaインターナショナル
        - 情報通信技術のさまざまな国際規格を策定している
            - 各規約には番号が振られている
                - ECMAScriptの規格番号 => ECMA-262
            - 様々な専門委員会
                - 委員会の名称　＝＞　TC39
    - JSのバージョン
        - ES2015（ES6)
            - JSは現在、Web開発において必須の存在となっている
                - 旧バージョンのJS5→新バージョンES2015（ES6)
                    - 旧バージョンよりも効率的にコードを書く事ができるようになったコード
    - scrict mode
        - 厳格な実行モード
            - 古く安全でない機能や構文が1部禁止される
                - use strictという文字列を関数orファイルの先頭に記載するとそのスコープではstrict modeが実行される
                    - moduleの実行コンテクストではデフォルトになっている
                        - 禁止される例：
                            - eval
                            - with
                                - 上記のようなレガシーな構文を禁止する
                                    - 明らかな問題を含んだコードに対しては早期に例外を投げる事で開発者が間違いを気づくようにする
    - 実行コンテクスト
        - Script
            - デフォルトがstrict modeではない
        - Module
            - デフォルトがstrict modeになっている
                - Moduleの実行コンテクストでのみ実行される
    - 大文字と小文字を区別する
        - nemeとNAMEは違う言語として認識される
    - 予約語を持つ言語
        - 特別な意味を持つキーワード
    - 文と式
        - JavaScriptのソースコードを構成する文と式という構文的な概念について
            - 文と式の違いを理解する
                - どの場合にセミコロンを入れるかがわかるようになる
        - 文（Statement）毎に処理し、文末は;（セミコロン）で区切る
            - 特殊なルールでセミコロンがないぶんも自動的にセミコロンが代入される仕組みがある
                - 暗黙的な仕様に頼る事は進められない
        - 式　＝＞　値を生成し、変数に代入できるもの
            - 式の特徴として、式を評価すると結果の値を得る事ができるもの
                - 結果の値　＝＞　評価値
            - 42やfooなど
                - 1 + 1　というものもそうなる
        - 文　＝＞　処理する1ステップが1つの文
            - if文やfor文など
        - 式文
            - 式は文になる事ができる
                - 文になった式を式分と呼ぶ
                    - 文が書ける場所には式が書ける
        - ブロック文
            - {}で囲んだ範囲には複数の文を記載する事ができる
                - if文やfor文などの構文と組み合わせて使用する事が多い
                    - 単独でも記載する事ができる
                        - 例外としてブロックの末尾には;セミコロンが必要ない
        - 関数宣言（文）と関数式
            - どちらもfunctionというキーワードを利用する
                - 文と式の違い
                    - 関数宣言文にはセミコロンがなし
                    - 関数式にはセミコロンがある
                        - この差分はブロックで終わるか？式なのか？で変わる
    - データ型
        - JSは動的型付け言語のため静的型付け言語のような変数の型はない
            - しかし、文字列・数値・真偽値といった値の型は存在する
        - プリミティブ型　＝＞　基本型
            - イミュータブルな値という特性を持っている
                - 文字列であっても一度、作成したら変更できないイミュータブルの特性を持つ
            - 真偽値（Boolean）
                - trueまたはfalseのデータ型
            - 数値（Number）
                - 42 や 3.14159 などの数値のデータ型
            - 巨大な整数（BigInt）
                - ES2020から追加された9007199254740992nなど
                    - 任意精度の整数のデータ型
            - 文字列（String）
                - "JavaScript" などの文字列のデータ型
            - undefined
                - 値が未定義であることを意味するデータ型
            - null
                - 値が存在しないことを意味するデータ型
            - シンボル（Symbol）
                - ES2015から追加された一意で不変な値のデータ型
        - オブジェクト型
            - 複数のプリミティブ型 or オブジェクトからなる集合
                - 作成した後も値を変更する事ができる
                    - 値の変更というものは値自体を変更するのではなく、値の参照を変更するという事になる
            - プリミティブ型以外のデータ
                - オブジェクト、配列、関数、クラス、正規表現、Date
- ***JavaScriptの仕様***
    - 空白の扱い
        - 空白は個数が変わっても認識は変わらない
    - 出力
        - console.log("○○");
            - ("○○");内の○○を出力する事ができる
                - ()内の文字列は” or ’ のどちらかで囲む必要がある
                - 文末の;は必須ではないが記載する方が好ましい
    - コメントアウト
        - JavaScriptにおけるコメントの書き方
            - コメントはプログラムとして評価されない
                - ソースコードに対する説明を書くために利用する
        - １行のみのコメントアウト
            - //以降から行末までがコメントアウトされる
        - 範囲でのコメントアウト
            - /*から*/までの範囲がコメントアウトされる
        - HTML-likeコメントは後方互換性のためだけに存在する
    - 計算
        - 数値の計算
            - クウォーテーションは無しで計算式を記載する
                - console.log(3+4);
            - 掛け算「*」
            - 割り算「/」
            - 余りの計算「%」
        - 省略した記載方法（省略形）
            - X = X + 10 → X += 10
            - X= X - 10 → X -= 10
            - X= X * 10 → X *= 10
            - X= X / 10 →X /= 10
            - X= X % 10 → X %= 10
        - 文字列の連結
            - 連結させたい文字列同士を記号”＋”で囲む
                - 「"にんじゃ" + "わんこ"」→「"にんじゃわんこ"」
        - 文字列の連結と数値の計算の違い
            - 数値をクウォーテーションで囲んで記載すると計算されずに文字列として認識されて出力される
                - console.log(”3+4”);
        - ”＝”の意味
            - 等しいという意味ではなう右辺を左辺に代入するという意味
    - 変数の宣言（全て共通）
        - 変数同士を,（カンマ）で区切る
            - 同時に複数の変数を定義できる
        - 変数の宣言規則
            - 半角のアルファベット
            - _（アンダースコア）
            - $（ダラー）
            - 数字
                - これらを組み合わせた名前にする
        - 変数名は数字から開始できない
        - 予約語と被る名前は利用できない
    - 変数（let）
        - データ（値）の入れ物（箱）
            - 箱の名前が”変数名”
        - letは初期値を指定しない変数も定義する事ができる
            - 初期値が指定されない変数はundefinedで初期化される
        - なぜ変数を使用するのか？
            - 繰り返し使う事ができる
                - 例：同じ処理を複数回使いたい場合
                    - Aさん＋”おはようございます”
                    - Bさん＋”おはようございます”
                        - ”おはようござます”を変数で定義しておけば繰り返し使える
            - 変更に対応しやすい
                - 変更箇所が少ない
                    - 例:上記のような繰り返し同じ処理がある場合にも変数を定義していれば変数の値を変更する事で全体に変更がかかる
            - 値の意味がわかりやすい
                - 可読性が高くなる
        - 変数の定義
            - letでこれから変数名を定義しますという宣言になる
                - let 変数名 = 値
        - 変数の上書き
            - 定義された変数は変数名=上書きする内容とする事で再定義する事ができる
                - 変数名＝上書きする値
        - 変数の更新
            - 変数は変数自身に付け加えて更新する事もできる
                - let number = 5;
                - number = number+5;
                    - 更新した値は更新した値が保持される
        - 変数の命名ルール
            - ES6での命名ルール
                - 良い例
                    - 英単語を使用する
                        - name
                    - 2単語になる場合には大文字で区切る
                        - firstName
                - 悪い例
                    - 数字開始
                        - エラーになってしまう
                    - 日本語
                        - 望ましくない
                    - ローマ字
                        - 望ましくない
        - 変数の使用
            - 変数の定義を行い定義した変数に対して文字列などデータを代入する事で変数名を呼び出した際に代入したデータが出力される
                - 変数を呼び出す時にはクウォーテーションで囲まないという事に注意する
            - 変数は代入されているデータに応じて計算・連結する事ができる
                - 文字列の場合
                    - 変数に代入されていない文字列同様に使用する事ができる
                - 数値の場合
                    - 変数に代入されていない数値同様に計算などの処理を行う事ができる
    - 定数に近い変数を定義できる宣言(const)
        - 定数の定義
            - 一度、定義すると毎回同じ値を返す
        - const
            - constは定数ではない
                - constは再代入禁止の変数なのであってオブジェクトの値をプロパティを介して変更する事ができる 
            - 再代入禁止の変数
                - その変数が参照する値を定義する
                    - 再代入する必要がない場合に優先的に使用される変数
                        - 再代入が必要な場合にはletを使う
            - 実質的に的に
    - 変数（var）
        - letと同じように使う事ができる変数
        - letとconstとの違い（問題点）
            - 同じキーワードに対して再代入できてしまう点
                - 変数の上書きをしても構文エラーが起きない
        - 問題が出現したため新しくconstとletが追加された
            - var自体を改善しなかった理由
                - 後方互換性
    - 値の評価と表示
        - 変数の宣言をする事で値に名前をつける事ができる
            - 変数の宣言は返り値はない
    - 実行環境
        - ブラウザの違いや実行環境によってコードが動いた結果が変わる事がある
    - REPL（read–eval–print loop）
        - ブラウザにはWebコンソールという試したいコードを実行するツールがある
            - 変数の宣言をした結果はundifinedが帰ってくる
                - 変数の宣言は戻り値を持たない
                    - 変数を呼び出すと値が返ってくる
        - リロードするまで変数の宣言などが保たれる
            - 再定義などにはエラーが起きてしまった場合にはリロードする
    - JavaScriptを読み込む方法
        - WebサイトはHTMLで表示される
            - HTMLでJavaScriptを読み込む事でJavaScriptを実行する事ができる
    - リテラル
        - リテラルを使う事で簡単に定義する事ができる
            - 構文として定義されたもの
        - リテラル表現があるプリミティブ型とオブジェクト型
            - プリミティブ型
                - 真偽値
                    - true; false;
                        - 見た目通りに真偽値を示す
                - 数値
                    - 64ビットで数値を表現する
                        - 54ビットを数字の格納
                        - 11ビットを小数点の位置に使う
                        - 1ビットをプラスとマイナスに使う
                    - 整数リテラル
                      - 10進数　＝＞　数値
                      - 2進数　＝＞　ビット演算
                      - 8進数　＝＞　ファイルのパーミッションなど
                      - 16進数  ＝＞　コードポイントやRGB値など
                    - 浮動小数点リテラル
                        - ドットを含んだ数値
                        - eまたはEを含んだ数値
                            - 0から始まる浮動小数点は0を省略して記載する事ができる
                                - JSは.から始まるオブジェクトが多いため省略せずに記載する方が望ましい
                - BigInt
                    - 数値リテラルが扱う事ができる値は決まっている
                        - 上限を超えると正しい結果にならない可能性がある
                    - 数値リテラル　＝＞　64ビット
                    - Bigint ＝＞　任意の精度の整数
                        - 扱う事ができる整数の範囲が大きくなる
                - 文字列
                - null
            - オブジェクト型
                - オブジェクト
                - 配列
                - 正規表現
                    - /スラッシュとスラッシュ/で正規表現のパターン文字を囲む
                        - +や/で始まる特殊な文字が出現する
        - テンプレートリテラル
            - ${定数}とする事で文字列内に変数を埋めこむことができる
                - テンプレートリテラルを使用する場合には文字列全体をバッククォーテーション（`）で囲む必要がある
        - 
    - 条件分岐
        - if文（条件分岐）
            - ある条件がtrueの場合には実行する文の処理を行う
                - もし○○ならば●●を行うという処理を作ることができる
                    - if (条件式) {処理内容}　←；は必要なし
                        - 処理の内容を記載する{}は実行する文が一行のみの場合には必要ない
                            - if文の範囲がわからなくなってしまうため常に囲む事を勧められる
            - if文を書く際には中の処理内容はインデントする事を意識する
            - if文はネストする事ができる
                - if文の中にさらにif文を入れる事ができる
                    - ネストするif文の例：
                        - うるう年かを判定する
                            - 西暦で示した年が4で割り切れる年はうるう年です
                            - ただし、西暦で示した年が100で割り切れる年はうるう年ではありません
                            - ただし、西暦で示した年が400で割り切れる年はうるう年です
                                - この3つの条件が満たされるものがうるう年となる
            - 真偽値
                - if文は検証の結果をtrue or falseの2つで返す
                    - 真　＝　true
                    - 偽　＝　false
                        - falsyな値
                            - undefined
                            - null
                            - 0
                            - 0n
                            - NaN
                            - ""（空文字列）
            - else
                - if文の真偽値がtrue以外の場合に行う処理　＝＞　条件に一致しなかった場合
                    - 「もし〇〇なら●●を行う、そうでなければ■■を行う」という処理
                        - if (条件式){trueだった場合の処理内容}else{true以外だった場合の処理内容}
            - else if (条件)
                - if文がtrue以外だった場合にさらに条件を加える際の記載方法
                    - 3つの条件分岐するプログラムを作る事ができる
                    
                    ```jsx
                    if (条件1){
                    条件１がtrueだった場合に実行する処理内容
                    }else if(条件1がtrue以外だった場合の条件2){
                    条件2がtrueだった場合の処理内容
                    }else{
                    条件2がtrue以外だった場合の処理内容
                    }
                    ```
                    
            - かつ・または
                - かつ→&&
                    - 条件1&&条件2は条件1かつ条件2という意味になる
                        - 条件全てがtrueであればtrueになる処理
                - または→｜｜
                    - 条件1 || 条件2は条件1または条件2という意味になり
                        - 条件のいずれかがtrueであればtrueを返す処理
        - switch文　if文以外の条件分岐
            - 式の評価結果によって処理を分岐する方法
                - switch(条件の値){ 処理 }
                    - case 値1: break;
                        - caseと値が一致した場合にはcaseで定義した処理を実行する
                            - caseの分だけ条件分岐を設定できる
                                - breakを記載する事で条件分岐の終了を定義して次のcaseの条件分岐に移行する事ができる
                - 処理の流れ
                    - まず、条件部分を評価する
                        - 条件部分の評価に応じてcaseで定義した値が評価結果と**厳密に等しいか？**を判別していく
                
                ```jsx
                const name="kouki"
                switch (name){
                 case(値１):
                     値１が条件と等しい場合に実行される処理
                 break;
                 case(値２):
                     値２が条件と等しい場合に実行される処理
                 break;
                }
                ```
                
            - switch分のcaseどれにも当てはまらなかった場合
                - defaultを設定する
                    - default: 処理 break;
    - 演算子
        - 2項演算子 => 2つのオペランドに対する処理を行う
            - プラス演算子（+）
                - 2つのオペランドである数値を加算する演算子
                    - 整数と浮動小数点どちらもIEEE 754方式が採用されている
                        - どちらも加算する事ができる
            - マイナス演算子（-）
                - 2つのオペランドである数値を減算する演算子
            - 文字列結合演算子（+）
                - 2つのオペランドである文字列を結合する演算子
            - 乗算演算子（*）
                - 2つのオペランドである数値を累乗する演算子
            - 除算演算子（/）
                - 2つのオペランドである数値を徐算する演算子
                    - ０を徐算した場合には無限大を示すInfinityとなる
            - 剰余演算子（%）
                - 2つのオペランドである数値を徐算したあまりを求める演算子
                    - 左オペランドを右オペランドで徐算したあまりを求める
            - 大小を比べる演算子(比較演算子)
                - <
                    - 左辺は右辺より小さい
                - <=
                    - 左辺が右辺より小さい、もしくは等しい
                - >
                    - 左辺は右辺より大きい
                - >=
                    - 左辺は右辺より大きい、もしくは等しい
            - 等価演算子
                - ==
                    - 左辺と右辺が等しければtrue
                - !=
                    - 左辺と右辺が異なればtrue
                - 注意点
                    - 数値「12」と文字列「"12"」はデータの扱い上、文字列と数値となり異なるが、等価演算子においては文字列の12を数値の12に変換して処理しているため等しいものとして扱われる
            - べき乗演算子（**）
                - 2つのオペランドである数値をべき乗する演算子
                    - 左オペランドを右オペランドでべき乗した値を返す
                        - 同じ役割を持つ、Math.powメソッドが存在する
            - 厳密等価演算子
                - ===
                    - 右辺と左辺が厳密に等しい
                - !==
                    - 右辺と左辺が厳密に異なる
                - 厳密等価演算子においては数値「12」と文字列「"12"」は異なるものとして扱われるようになる。
                - 基本、理由がなければ厳密等価演算子を使用するようにする
        - 単項演算子 => 1つのオペランドを受け取る演算子
            - 単項プラス演算子（+）
                - オペランドを数値に変換する
                    - 文字列を数値に変換する
                        - 数値に変換する事ができない文字列などはNaNという特殊な値に変換される
                            - NaN => Not-a-Numberの略称
            - 単項マイナス演算子（-）
                - マイナスの数値を表す場合に利用する
            - デクリメント演算子
                - オペランドの数値を-1する演算子
            - インクリメント演算子（++）
                - オペランドの値を+1する演算子
                    - 前置インクリメント演算子
                        - 演算してから状態を評価する
                    - 後値インクリメント演算子
                        - 演算前のオペランドの状態を評価
                        - その後に演算を実行する
                        - 最終結果としてはインクリメントされる
        - ビット演算子
            - オペランドである数値を符号付き32ビット整数として扱う
                - 1 => 00000000000000000000000000000001
                    - 先頭の最上位ビットは符号を示す
                - 0 => 正の値
                - 1 => 負の値
            - -1の符号付き32ビット整数
                - 0000_0000_0000_0000_0000_0000_0000_0001 => 10進数の1
                
                  ↓
                - 1111_1111_1111_1111_1111_1111_1111_1110 => 反転したビット
                
                　↓
                - 1111_1111_1111_1111_1111_1111_1111_1111 => 1ビットを足す
            - ビット論理積（&）
                 - ビットごとのAND演算した結果を返す
            - ビット論理和（|）
                - ビットごとのOR演算した結果を返す
            - ビット排他的論理和（^）
                - ビットごとのXOR演算した結果を返す
            - ビット否定（~）
                - オペランドの各ビットを反転した値を返す
            - 左シフト演算子（<<）
                - bitの数だけ左にシフトする
            - 右シフト演算子（>>）
                - bitの数だけ右へシフトする
            - ゼロ埋め右シフト演算子（>>>）
                - 数値であるnumをbitの数だけ右へシフトするのは右シフト演算子（>>）と同じ
                    - 異なる点は右にあふれたビットは破棄されて0のビットを左から詰める
            - Nullish coalescing演算子(??)
                - 左辺の値がnullishであるなら、右辺の評価結果を返す。 
                    - nullishとは、評価結果がnullまたはundefinedとなる値のこと
        - 論理演算子
            - 短絡評価 => 評価が決まった段階で評価をやめる
                - AND演算子（&&）
                    - 左辺の値の評価結果がtrueならば、右辺の評価結果を返す。
                    - 一方で、左辺の値の評価結果がfalseなら、そのまま左辺の値を返します。
                - OR演算子（||）
                    - 左辺の値の評価結果がtrueならば、そのまま左辺の値を返す。 
                    - 一方で、左辺の値の評価結果がfalseであるなら、右辺の評価結果を返す。
                        - 暗黙的な型交換をおじょなう
                            - 左辺がfalsyな値の場合には右辺の値を返す
            - falsyな値 => 暗黙的な型変換
                - false
                - undefined
                - null
                - 0
                - 0n
                - NaN
                - ""（空文字列）    
    - 被演算子(オペランド)
        - 演算子に演算される対象の事をオペランドと呼ぶ
            - 2項演算子
                - 2つのオペランドを取る演算子の事をいう
            - 単項演算子
                - 1つのオペランドを取る演算子
    - 暗黙的な型変換
        - なぜJSでは等価演算子を使う時に厳密等価演算子の使用を推奨しているのか？
            - JSにおいては暗黙的な型変換が存在している
                - 厳密等価演算子は暗黙的な型変換を行わずに比較することができる
        - 数値と真偽値の加算
            - 多くの言語ではエラーになる計算
                - JSにおいては真偽値が演目的な型変換が行われてエラーが起きない
                    - エラーが起きないためバグの発見が困難になることがある
        - 暗黙的な型変換とは？
            - ある処理において、その処理過程で行われる明示的ではない型変換のこと
        - ＋演算子
            - JSにおいては文字列の結合が両方実行できるように多重定義されている
                - 数値＋文字列であれば暗黙的な型変換が重要
                    - 2つのみの単純なオペランドに対する演算であれば結果は予想できる
                        - 複数のオペランドを対象に取った時に明示的な型変換をすることがコードの可読性や保守性を担保する
        - 明示的な型変換
            - プリミティブ型へ明示的な型変換する方法
                - 任意の値　＝＞　真偽値
                    - 任意の値から真偽値に変換する
                        - Boolean()
                            - falseに変換される値 => falsyな値
                                - false
                                - undefined
                                - null
                                - 0
                                - 0n
                                - NaN
                                - ""（空文字列）
                - 数値から文字列
                    - String() => Stringコンストラクタ
                - シンボルから文字列
                    - 文字列　＋　シンボル
                        - symbolオブジェクトは暗黙的な型変換の対象ではない
                - 文字列から数値
                    - Number() => Numberコンストラクタ
                - 様々な場所で見るNaN(Not a Number)
                    - NaNはNumberクラスのオブジェクト
                        - NaNは計算過程で出てきた場合にはその計算結果を必ずNaNにする特性がある
                            - バグが起きてもどこでNaNに変換されたのかわからないことが多々ある
                                - 対策方法
                                    - sum関数側（呼ばれる側）で、Number型の値以外を受けつけなくする
                                        - 呼ばれる側で対応する
                                            - 
                                    - sum関数を呼び出す側で、Number型の値のみを渡すようにする
                                        - 呼び出す側で対応する
                - 明示的に型変換をしても無理な場合
                    - そもそも型の変換が必要なことなのか考える
                - 空文字か判断する
                    - 空文字はfalsyな値である
                        - 0も空文字になってしまう
                            - falsyな値は多くあるため絞り込むことができない
                                - 真偽値への値の変換を行う場合には条件を定義する事で変換する
                                    - 空文字　＝＞　length === 0　のような形
            - まとめ
                - 暗黙的な型変換は意図しない結果となりやすいため避ける
                - 比較には等価演算子（==）ではなく、厳密等価演算子（===）を利用する
                - 演算子による暗黙的な型変換より、明示的な型変換をする関数を利用する
                - 真偽値を得るには、明示的な型変換以外の方法もある
    - voidという型
        - 式が値を返さない事を示すために使用するもの
            - 関数が値を返さないようにする
            - 特定の式の評価結果を無視する
        - 使い方
            - 式の計算結果
            
            ```tsx
            let result = void 0;  // undefined が代入される
            console.log(result);   // 出力: undefined
            ```
            
            - 関数での使い方
            
            ```tsx
            function doNothing() {
              void console.log("This does nothing and returns undefined.");
            }
            doNothing();
            // 出力:
            // This does nothing and returns undefined.
            ```
            
            - voidを使ったHTMLのイベントハンドラ
            
            ```tsx
            <a href="javascript:void(0)" onclick="alert('Clicked!');">Click me</a>
            ```
            
            - voidとクロージャ
            
            ```tsx
            let counter = (function() {
              let count = 0;
              return function() {
                return void count++;
              };
            })();
            
            counter();  // count は増加するが、何も返さない
            counter();  // count は再度増加するが、何も返さない
            ```
            - voidを使うと常に結果がundefinedになる
    - 総合的に知識チェック
        
        ```jsx
        console.log("表示させたい文字列");
        console.log(数値+数値);
        console.log(数値-数値);
        console.log(数値*数値);
        console.log(数値/数値);
        "8" 文字列
        8 数値
        
        let name = "mutsukura";
        console.log(name);
        console.log("name");//文字列としてのnameが出力される
        変数はデータに名前をつけた箱
        箱に名前をつけたものが変数名
        
        const 定数名　= 値
        厳密な定数は上書きできない値
        JavaScriptにおける定数は再代入禁止なもの
        const parson = {name: "ムック",age: 21}
        parson = ランタイムエラーが起きる
        parson.name = "堤竹"
        ↑
        技術面接などで聞かれやすい
        技術において似た概念が多く存在する
        概念同士の違いを理解する事が重要
        
        条件分岐
        let age = 20;
        if (age >= 18 ) {
         console.log("成人です。");
         }
        ```       
    - 繰り返し処理(ループと反復処理)
        - JavaScriptにおいて繰り返して同じ処理を行う場合に何度もコードを記載する必要はない
            - ループやイテレーターを使って反復処理を行い実行する事ができる
        - while文
            - 複数回同内容の処理を行う際に全ての回数分処理を書くのは厳しいため条件を設定して繰り返し処理を行う
                - while (条件式){処理内容}
                    - 条件式がtrueの場合に処理を行う(反復)
            - 処理の流れ
                - 条件式 の評価結果がtrueなら次のステップへ、falseなら終了
                - 実行する文を実行
                - ステップ1へ戻る
            - 注意点
                - 無限ループに気をつける
                    - 処理内容を定義して実行してから処理内容を適用して更新する事を忘れないようにする事が必要
                        - 実行する分の中で条件式に対して効果を与えて最終的にはfalseになるようにする事が重要
        - for文
            - while文と同じく繰り返し処理を行うが条件式などの記載方法が簡潔になっている
                - for (変数の定義:条件式:変数の更新){処理内容}
                    - 繰り返す範囲を指定した反復処理を記載する事ができる
            - 実行フロー
                - 初期化式 で変数の宣言
                - 条件式 の評価結果がtrueなら次のステップへ、falseなら終了
                - 実行する文 を実行
                - 増分式 で変数を更新
                - ステップ2へ戻る
            - 省略した書き方
                - 「number += 1」は「number ++」
                - 「number -= 1」を「number --」
                    - と省略して記載できる
            - 数値が3倍の場合のコード記載
            
            ```jsx
            for (let number=1;number <= 100 ; number ++) {
            
            // if文を用いて、numberが3の倍数の時に「3の倍数です」、そうでないときは数字を出力してください
            if (number %3 === 0){
                console.log("3の倍数です")
            }else{
                console.log(number)
            } 
            }
            ```
        - do-while文
            - while文とほとんど同じ
                - 実行順序が変わる
            ```Ruby
            do {
                実行する文;
            } while (条件式);
            ```
            - 処理のフロー
                - 実行する文を実行
                - 条件式 の評価結果がtrueなら次のステップへ、falseなら終了
                - ステップ1へ戻る
            - while文との違い
                - まず最初に処理を行う
                    - 条件を満たさない場合にも最初の処理は必ず実行される点が違う
    - 配列
        - 複数の値をまとめる方法として配列という方法がある
            - [値1, 値2, 値3]と記載する事で配列にする事ができる
                - 配列は定数に代入する事ができる
                    - 配列を代入した定数は習慣上複数形にする
                - console.log(定数名)とする事で代入した定数を出力する事ができる
                    - 配列内の値を要素と呼ぶ
        - 配列はArrayクラスのオブジェクトである
            - Arrayオブジェクトの反復処理のためのメソッドが備わっている
        - インデックス番号
            - 配列内の要素は0から始まりインデックス番号がついている
                - 配列内の要素を取得したい場合には
                    - console.log(変数名[要素のインデックス番号]); とする事で出力する事ができるようになる
        - 要素の更新と定数の再定義の違い
            - 配列を定義した定数に新たな定数を代入する事ができない、だが、要素の値を更新する事は可能
        - 配列名.length
            - 配列の数、数値を代入するもの
                - 配列に対する繰り返し処理などの際に多く活用する事が多い
        - forEachメソッド
            -  for文と同じような反復処理を行うメソッド
                - for文のようにiといった一時的な条件の定義をする必要がない事でシンプルに記載できる利点がある
            ```Ruby
            const array = [1, 2, 3];
            array.forEach(currentValue => {
                // 配列の要素ごとに呼び出される処理
                // currentValueには配列の1~3の値が順番に渡される
            });
            ```
            - 無名関数を引数として渡す
                - 渡される関数　＝＞　コールバック関数
                - コールバック関数　＝＞　高階関数
            - 例えば、sum関数
                - ```Ruby
                    function sum(numbers) {
                        let total = 0;
                        numbers.forEach(num => {
                            total += num;
                        });
                        return total;
                    }

                    sum([1, 2, 3, 4, 5]); // => 15
                ```
        - break
            - 繰り返し処理やループを抜け出し次のループに制御を移す
        - continue文
            - while、do-while、forの中で使う事ができる
                - 現在の反復処理を終了して次の反復処理を行う
        - filter関数
            - 条件に応じた特定の処理のみを集めて配列を作成するメソッド
        - for...in
            - オブジェクトのプロパティに対して、反復処理を行う
            ```Ruby
            for (プロパティ in オブジェクト) {
                実行する文;
            }
            ```
            - 一つのオブジェクトに対して1つのブロックを作成して反復処理を行う
            ```Ruby
            const obj = {
                "a": 1,
                "b": 2,
                "c": 3
            };
            // 注記: ループのたびに毎回新しいブロックに変数keyが定義されるため、再定義エラーが発生しない
            for (const key in obj) {
                const value = obj[key];
                console.log(`key:${key}, value:${value}`);
            }
            // "key:a, value:1"
            // "key:b, value:2"
            // "key:c, value:3"
            ```
            - for...in文の注意点
                - JavaScriptにおけるオブジェクトは様々なプロパティを継承している可能性があり、親オブジェクトまで列挙可能なオブジェクトをあげてしまう可能性があり
                    - その場合、意図しない結果になってしまう可能性がある
            - 安全に列挙する方法
                - Object.keysメソッド
                    - 引数のオブジェクト自身が持つプロオアティを出力する
                - Object.valuesメソッド
                    - 
                - Object.entriesメソッド
    - オブジェクト　＝＞　Objectというビルトインオブジェクト
        - 複数の値を管理する方法
            - オブジェクト
                - プロパティの集合
                    - プロパティ　＝＞　名前（キー）と値（バリュー）が対になったもの
                        - キー
                            - 文字列 or Symbolが利用できる
                                - 値には任意のデータを指定する事ができる
                                    - 1つのオブジェクトで複数のプロパティを持てる
            - 値に対してプロパティ名をつける事で管理する
                - オブジェクトは{}で囲む　＝＞　オブジェクトリテラル
                - プロパティ名と値の間はコロン（ : ）で繋ぐ
                - プロパティ間はコンマ（,）で区切る
                    - キーの初期値を定義する
                        - クォート（"や'）を省略できる
                            - 変数名として使う事ができないハイフンなどが出てくる場合にはクォート（"や'）で囲む必要あり
            - オブジェクトも定数に代入する事が可能
        - オブジェクトの値を取り出す
            - オブジェクト.プロパティ名とする事で取り出せる
        - オブジェクトの値を更新する
            - オブジェクト.プロパティ名 = 新しい値
        - オブジェクトを要素に持つ配列
            - 配列の要素がオブジェクトになっている場合
                - オブジェクトに対してインデックス番号が振られている
                    - 配列内のオブジェクトの値を取り出す
                        - 配列[インデックス番号].プロパティ名
        - オブジェクトの値に変数名を指定すると変数の参照先をオブジェクトが参照する事になる
            - 指定する変数とプロパティ名が一緒の場合には省略して記載する事ができる
        - オブジェクト内のプロパティにオブジェクトを用いる事ができる
            
            ```jsx
            const names = {
                name:{
                    firstName:"kouki"
                    homename:"mutskura"
                    }
                };
            
            ```
            
            - 呼び出し方法
                - .記法
                    - 「オブジェクト名.プロパティ.プロパティ」
                - []ブランケット記法
                    - console.log(obj["key"]);
                        - 暗黙的に文字列に変換されてプロパティを探す事ができる
        - オブジェクト内のプロパティの値には配列を用いる事も可能
            ```jsx
            const nameList = {
                name:["kouki","toyoda","tutumitake"]
            };
            ```
        - オブジェクトの例
                - 配列・関数　＝＞　オブジェクトの一種
        - Objectというビルトインオブジェクト
            - ECMAScriptの仕様で定義されているもの
                - あらゆるJS環境で利用する事ができる
                    - {}はObjectのインスタンスオブジェクト
                        - {} => new Objet()
                            - 同義である
    - undefined
        - 存在しないプロパティなどを指定すると特別な値のundefinedが出力される
            - 未定義のプロパティという意味
    - 関数
        - 関数とは
            - いくつかの処理をまとめたもの
                - 関数を構成すつ4つの要素
                    - 関数名 - 利用できる名前は変数名と同じ
                    - 仮引数 - 関数の呼び出し時に渡された値が入る変数。複数ある場合は,（カンマ）で区切る
                    - 関数の中身 - {と}で囲んだ関数の処理を書く場所
                    - 関数の返り値 - 関数を呼び出したときに、呼び出し元へ返される値
        - 関数の定義
            - const 定数名 = function(){}
                - {}の中にまとめたい処理を書く事で関数を用意できる
                    - 関数を用意する事を関数を定義するという
        - 関数の呼び出し
            - 関数を定義した際に使用した定数名を使用して関数を呼び出す
                - 定数名();
        - Console API
        - アロー関数
            - 通常、変数の定義はfunction()で行うがES6から() => と記載する事でも関数の定義ができる
        - 引数
            - 引数とは
                - 関数を呼び出した際に渡すデータ
                    - 括弧の中に引数名を書く事で引数を受け取る事ができる
                        - (引数名) =>
                    - 関数を呼び出す際に引数を渡す事で関数に値が渡される
                        - 定数名(引数として渡す値);
                            - 引数として渡した値が引数名に代入される
            - 複数の引数を受け取る関数
                - 受け取る引数をコンマ(,)で区切って並べることで、複数の引数を指定することができる。
                    - 左から順に第1引数、第2引数、第3引数のようになっていく
                        - 関数側で設定した仮引数よりも少ない数の引数が渡された場合にはundefinedが代入される
                        - 関数側で設定した仮引数よりも多い場合、溢れた引数は無視される
                - [ES2015] デフォルト引数
                    - 仮引数に対応する引数が渡されていない場合のデフォルトで代入される値を指定する事ができる    
                        - ```JavaScript
                            function echo(x = "デフォルト値") {
                                return x;
                            }

                            console.log(echo(1)); // => 1
                            console.log(echo()); // => "デフォルト値"
                        ```
                - 可変長引数
                    - 任意の個数の引数を受け取る事ができる
                        - Rest parameters
                            - 仮引数名の前に...をつけた仮引数 => 残余引数
                                - 関数に渡された値が配列として代入される
                                    ```JavaScript
                                    function fn(...args) {
                                        // argsは、渡された引数が入った配列
                                        console.log(args); // => ["a", "b", "c"]
                                    }
                                    fn("a", "b", "c");
                                    ```
                                - 通常の仮引数と組み合わせる事ができる
                                    - 条件：
                                        - 必ず、末尾にRest parametersが来るようにする
                            - 値をまとめて配列にして代入する仕組みがRest parameters
                                - 配列を展開して代入する仕組みも存在する
                                    - Spread構文
                                        - 配列の前に...をつけた構文
                                            - 配列の値を展開したものが引数として渡される
                        - 関数の中でのみ参照できる特殊な変数arguments
                            - 渡された値が全て入ったArray-Likeなオブジェクト
                                - 値をインデックス要素でアクセスする事ができる
                                    - しかし、Arrayオブジェクトのメソッドなどを使用する事はできない
                    - Rest Parametersが使用できる場面でarguments変数を使う理由はない
                        - Arrow Functionでは利用できない（Arrow Functionについては後述）
                        - Array-likeオブジェクトであるため、Arrayのメソッドを利用できない
                        - 関数が可変長引数を受けつけるのかを仮引数だけを見て判断できない
                - 分割代入（Destructuring assignment）
                    - オブジェクトや配列からプロパティを取り出し、変数として定義し直す構文
                        - 関数に渡す引数を右辺と考えるとほぼ同じ構文である
                            - オブジェクトに対する分割代入
                                
                                ```JavaScript
                                    const user = {
                                        id: 42
                                    };
                                    // オブジェクトの分割代入
                                    const { id } = user;
                                    console.log(id); // => 42
                                    // 関数の引数の分割代入
                                    function printUserId({ id }) {
                                        console.log(id); // => 42
                                    }
                                    printUserId(user);
                                    ```
                            - 配列に対する分割代入
                                
                                 ```JavaScript
                                    function print([first, second]) {
                                        console.log(first); // => 1
                                        console.log(second); // => 2
                                    }
                                    const array = [1, 2];
                                    print(array);
                                    ```
        - 戻り値
            - 関数での処理結果を戻り値として受け取る
                - 関数内でreturnと記載する
                    - 呼び出した関数に戻り値がある場合には呼び出し元が戻りにそのまま代入される
                - returnは実行されると関数の処理を終了させる性質がある
                    - 処理を何もしない場合にはreturnのみを記載する事でundifindを返す事ができる
                - returnの記載を省略する事も可能
            - 戻り値の活用
                - 真偽値の取得
                    - if文の条件式をreturnすると条件式の結果として真偽値(true or false)を得る事ができる
        - スコープ
            - 定数や変数の使用できる範囲の事
                - 関数の外側で定義した定数、変数はプログラムのどこからでも使う事ができる
                - 関数の{}で定義した定数や変数は定義した関数内のみで使用できる
                    - while文などの中括弧がある構文でもスコープが作成される
            - 同じ名前の定数、変数がある場合にもスコープの範囲に応じて処理が変わる
        - 関数はオブジェクト
            - JSにおいて関数は関数オブジェクトと呼ばれる
                - 関数を値として扱う事ができる
                    - ファーストクラスファンクション
                        - 関数式
                            - functionキーワードを使った方法
                                - 関数を値として変数へ代入している
                                    - 名前を持たない関数(無名関数)を定義する事ができる
                            - Arrow Functionを使った方法
                                - 矢印のような=>（イコールと大なり記号）を使い、無名関数を定義する構文
                                    - 関数の引数が1つの時には()を省略する事ができる
                                    - 関数の処理が1つの場合にはブロックとreturn文を省略する事ができる
        - 同じ関数名の宣言は上書きされる
            - 関数宣言で定義した関数は関数の名前のみで区別される
                - 同じ名前での定義は後ろで定義した関数が定義される
                    - 予期していない挙動になる事があるため基本的には同じ名前での定義は行わない
        - コールバック関数
            - ファーストクラスとしての関数を関数に引数として渡す事
                - 高階関数と呼ぶ
        - メソッドの短縮記載
            - メソッドとしてプロパティを定義するための短縮した書き方
                - オブジェクトリテラルの中で メソッド名(){ /*メソッドの処理*/ }と記載する
                    ```JavaScript
                    const obj = {
                        method() {
                            return "this is method";
                        }
                    };
                    console.log(obj.method()); // => "this is method"
                    ```
    - クラス構文
        - クラスとは
            - 効率よくオブジェクトを作成するための設計図
                - 複数のオブジェクトを作成する際の型
            - クラスの用意
                - class クラス名
                    - クラス名は基本、大文字で開始する
            - インスタンスの作成
                - クラスを元にオブジェクトを作成する
                    - new クラス名()
                        - クラスを元に作成したオブジェクトをインスタンスと呼ぶ
                            - AnimalクラスのインスタンスをAnimalインスタンスと呼ぶ
            - コンストラクター
                - 設計図の中身
                    - インスタンスの作成時や設定内容を追加するための機能
                        - インスタンスが作成される毎に実行される
                - クラスの{}内に記載する
                    - constructor() { }
                - 作成されたインスタンスにプロパティと値を追加する方法
                    - this.プロパティ名 = 値
                        - クラスの外でインスタンス.プロパティ名とする事でクラスの外でも使用する事が可能になる
                - 引数を受け取る
                    - コンストラクタは引数を受け取る事ができる
                        - インスタンス毎に値を変えたい場合などに対応できるように
                            - 引数を()内で受け取って、{}内でthis.引数名などとして引数を受け取る
                                - インスタンスを作成する際に値を渡してコンストラクタが受け取れるようにする
            - メソッド
                - 情報（名前や年齢）を追加したのがプロパティ
                - メソッドはインスタンスの動作、振る舞いを設定する
                    - クラス内でメソッド名() { }のように記載する
                - メソッドの呼び出し方
                    - インスタンス.メソッド名()
                - インスタンス内でメソッドを使用する場合
                    - thisを使用する
                        - **this.プロパティ名**
                - メソッド内でメソッドを使う
                    - this.メソッド名()
    - クラスの継承
        - 継承とは？
            - すでに作成したクラスを元に新しいクラスを作成する事
                - 「Animalクラス」を継承して「Dogクラス」を作成する場合
                    - 「class Dog extends Animal」と書く
                - 親クラス、子クラス
                    - 親クラス
                        - 継承される元のクラス
                    - 子クラス
                        - 元のクラスを継承するクラス
            - 親クラスのメソッドを使う
                - 親クラスで定義されたメソッドは子クラス内でも使う事が可能
                    - インスタンス.メソッド名();
            - 子クラス内で独自のメソッドを作成する
                - 子クラス内では独自にメソッドを作成する事が可能
                    - 通常と同じようにメソッド名(){}と記載する
            - メソッドの戻り値
                - 関数と同じでメソッドは戻り値を受け取る事ができる
        - オーバーライド
            - 継承先の子クラスで継承元の親クラスと同名のメソッドを作成した場合はどうなるのか？
                - 子クラスで定義したメソッドに内容が上書きされる
    - ファイルの分割
        - コードの量が多くなってくると一つのファイルで管理する事が困難になるためファイルを区切りで分割する
            - ファイルを分割すると当たり前だが分割した部分のコードがなくなってしまい必要な処理がなくなってしまうためエラーになってしまう。
        - エクスポート
            - クラスの定義の後にexport default クラス名とする事でクラスをエクスポートして他のファイルに渡す事ができる
        - インポート
            - 他のファイルで定義されているクラスを使用するにはインポートをする必要があるimport クラス名 from "./ファイル名”
    - 値のエクスポート
        - クラスのみではなく、メソッドや定数など値は分割する事が可能になっている
            - エクスポート
                - export default 分割したい値
            - インポート
                - import 分割したい値 from "./ファイル名”
        - デフォルトエクスポート
            - 各ファイルにつき1回までしか使う事ができない
                - インポートの際に分割したい値が間違えていてもデフォルトとしてエクスポートされるようになっている
    - 名前付きエクスポート
        - export defaultは1回しか使用できない。
            - その他の方法として名前付きエクスポートがある
        - 名前付きエクスポート
            - export {値の名前}
                - カンマを使う事で複数の値を指定してエクスポートする事ができる
        - 名前付きエクスポートしたものをインポートする
            - import { 値の名前 } from "./ファイル名”
                - インポートの際も同様でカンマで区切る事で複数の値をインポートできる
    - 相対パス
        - importする際のファイルを指定方法
            - ファイルを指定する際にはimportをするファイルからみたexportの位置関係を示している
        - 同じディレクトリ内にいる場合
            - ./ファイル名;
                - ./で同じディレクトリという事を示す
        - 異なるディレクトにいる場合
            - 同じ親ディレクトリ内のディレクトリが違うファイルを指定する方法
                - ./ディレクトリ名/ファイル名;
                    - ./ディレクトリ名/で同じディレクトリ内のディレクトリ名を指定する
                    - その後、ファイル名を指定する
        - 1つ上の階層に戻る必要がある場合
            - ../ディレクトリ名/ファイル名;
                - 親ディレクトリ内の違うディレクトリに入っているファイルを指定したい場合
                    - ../でディレクトリの階層を戻る
                    - ディレクトリ名の指定をする
                    - ファイル名の指定
    - パッケージ
        - 他の人が作成した機能を使う事ができる
            - JavaScriptの機能を使う事でプログラムに組み込む事ができる
        - import 定数名 from “パッケージ名”;
            - 例：chalk “文字列に対して色をつける事ができパッケージ”
                
                ```jsx
                import chalk from "chalk";
                console.log(chalk.yellow(colorisyellow));
                ```
                
            - 例：readline-sync　”コンソールへの入力、入力された値をプログラムで使用する”
                - readlineSync.question(質問文)
                    - 入力された内容を定数に代入すると入力内容がそのまま代入される
                - 整数の入力を要求する時
                    - readlineSync.questionInt(質問文) 　とする
            
            ```jsx
            import readlineSync from readlinesync
            const name = readlineSync.question("名前を入力してください”)
            const age =  readlineSync.questionInt("年齢を入力してください”)
            new human (name,age) 
            ```
    - pushメソッド
        - 配列の最後に値を追加する事ができるメソッド
            - 配列名.push(配列の最後に追加したい値）
    - forEachメソッド
        - 配列内の全ての要素に対して繰り返して同じ処理を行う事
            - アロー関数が入っている
                - 引数に対して処理を行う
            - コールバック関数
                - 引数に入っている関数はコールバック関数と呼ばれる
            - 良いコードを書く
                - 関数が1列に長くなってしまうと悪い関数になってしまう
                    - {で改行すると良いコードになる
            - 配列名.forEach(アロー関数)
                - (character) => {console.log(character);}
            
            ```jsx
            characters.forEach((character) => {
            console.log(character);
            });
            ```
        - メソッドの中に関数が入る形の記載が多くなってくる
    - findメソッド
        - 配列から条件式に合う1つ目の要素を配列の中から取り出すメソッド
            - 要素を順番に検証していき1番最初に対応するものがあったらその情報を元に操作を行う。
                - コールバック関数の中身
                    - { return 条件 }　と記載する
            - 要素がオブジェクトの場合にもプロパティを指定する事でオブジェクトそのものを呼び出す事ができる
    - filterメソッド
        - 配列から条件に合う要素を全て取り出して配列にするメソッド
            - findメソッドと同様に要素がオブジェクトの場合においてもプロパティを指定する事でオブジェクトそのものを呼び出す事ができる
    - mapメソッド
        - 配列内の要素全てに対して共通する処理を行い、処理を行った要素で新しい配列を作るメソッド
            - コールバック関数の中身
                - { return 値 }
            - 配列のオブジェクト要素に対しても使うこともできる
                - return name.firstname + name.lastName
    - コールバック関数に関して
        - Webアプリ開発においてコールバック関数は頻出であり理解する事が開発において必要
            - 関数の引数に他の関数を渡している関数をコールバック関数と呼ぶ
    - JavaScriptの関数において渡せるもの
        - 文字列
        - 数値
        - 真偽値
        - 関数　→コールバック関数と呼ぶ
    - コールバック関数の流れ
        - 関数は、関数名の後ろに()をつけると呼び出される。
            - ()をつけなければ関数そのものを指す。
        ```jsx
        const printWanko = () => {
        console.log("にんじゃわんこ");
        };
        
        const call = (callback) => {
        console.log("コールバック関数を呼び出します");
        callback();
        };
        
        call(printWanko);
        
        ```  
    - 関数の流れ
        1. 関数printWankoを定義する
            - 実行されると文字列としてのにんじゃわんこを出力する
        2. 関数call**を定義する**
            - 実行されると引数として関数callbackを渡す。
                - 文字列としてのコールバック関数を呼び出しますを出力する
                - callbackに引数として渡された関数printWankoを実行する
        3. 関数callを呼び出し、引数として関数printWankoを渡す
    - コールバック関数は事前に定義した関数だけなく、直接定義する事も可能
        
        ```jsx
        () => {
          console.log("ひつじ仙人");
        }
        ```
        
        ```jsx
        // 事前に関数を定義して渡す
        ↓
        const printWanko = () => {
          console.log("にんじゃわんこ");
        };
        
        const call = (callback) => {
          console.log("コールバック関数を呼び出します。");
          callback();
        };
        
        call(printWanko);
        
        // 直接アロー関数を定義して渡す
        ↓
        // 引数で関数を定義して渡してください
        call(() => {
          console.log("ひつじ仙人");
        });
        ```
        
        - 渡す引数に応じて関数で表示される内容を変える事ができる
        - 複数の引数を渡す事もできる
            - 渡す引数の数、順番は間違えないように注意が必要
        
        ```jsx
        const call = (callback) => {
          callback("にんじゃわんこ", 14);
        };
        
        call((name,age) => {
          console.log(`${name}は${age}歳です。`);
        });
        
        ```
        

JavaScript Primer

- 第一部: 基本文法
    - コメント
        
    - 変数と宣言
        - JavaScriptで変数を宣言する方法について紹介します。変数を宣言する方法にはconst, let, varがあります。これらの動作の違いや使い分けについて紹介します。
        
        **まとめ**
        
        - 変数を宣言するキーワード
            - const
                - 再代入禁止の変数を宣言する
            - let
                - 再代入可能な変数の宣言をする
            - var
                - 再代入可能な変数だが問題が報告されている
    - 値の評価と表示
        - ブラウザでJavaScriptコードを実行する方法について紹介します。またプログラムを実行すると遭遇するエラーをどのように解決していくかを紹介します。エラーを大きく2種類に分けて、構文エラーと実行時エラーについてそれぞれの問題点と解決の糸口を紹介します。
        
        **まとめ**
        
        - JavaScriptをブラウザ上で実行する方法
            - 開発者ツールを使う方法
            - HTMLからJavaScriptを読み込む方法
                - サンプルコードを自分で動かして改変させていく
        - エラーに関して
            - JavaScriptにおいてエラーが発生した場合にはコンソールにエラー位置を教えてくれる事が大多数である
                - エラー情報を元にデバックすれば基本的には問題なく解決できるはず
                    - エラーを怖がらずにやってみる
            - エラーはJavaScriptのエラーリファレンスに多数報告されている
                - 不明な場合にはGoogleなどに同内容のエラーを載せている人がいるはず
    - データ型とリテラル
        - JavaScriptの値の種類にあたるデータ型について紹介します。データ型には大きく分けてプリミティブ型とオブジェクトがあり、それぞれのデータ型を簡単なコード例とともに紹介していきます。一部のデータ型にはリテラルというデータ型を簡単に記述するための構文が用意されており、リテラルについても合わせて紹介していきます。
        
        **まとめ**
        
        - データの型
            - 7種類のプリミティブ型とオブジェクトがある
                - プリミティブ型の真偽値、数値、BigInt、文字列、nullはリテラル表現がある
                    - プリミティブ型のデータでもプロパティアクセスができる
                - オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
        - リテラル
            - リテラルはデータ型の値を直接記述できる構文として定義されたもの
    - 演算子
        - JavaScriptにおける演算子について紹介します。演算子は記号で表現されるため、検索しにくいです。この章では主要な演算子をまとめて紹介しています。知らない演算子が出てきたときに読み直せばよいため、すべてを1つずつ読む必要はありません。
        
        **まとめ**
        
        - 演算子
            - よく利用する演算処理を記号などで表現したもの
                - 四則演算
                - 論理演算など
                    - 演算子には優先順位が定義されている
                    - グループ化演算子で明示可能
    - 暗黙的な型変換
        - JavaScriptの暗黙的な型変換は意図しない挙動を発生する原因の1つです。暗黙的な型変換が発生する具体的なコード例や予測が難しいことについて紹介します。逆に明示的に変換する方法についても紹介します。
        
        **まとめ**
        
        - 暗黙的な型変換
            - 暗黙的な型変換は意図しない結果となりやすいため避ける
        - 明示的な型変換
            - 比較には等価演算子（`==`）ではなく、厳密等価演算子（`===`）を利用する
            - 演算子による暗黙的な型変換より、明示的な型変換をする関数を利用する
            - 真偽値を得るには、明示的な型変換以外の方法もある
    - 関数と宣言
        - JavaScriptの関数を定義する方法について紹介します。関数やメソッドを定義する方法として関数宣言、関数式、Arrow Functionについて紹介します。また関数の引数の扱い方や関数とメソッドの違いについても紹介します。
        
        **まとめ**
        
        - 関数の宣言方法
        - 関数を値として使う方法
        - 関数式とArrow Function
        - コールバック関数
        - メソッドの定義方法
            - 基本的な関数の定義や値としての関数について
                - JSは非同期処理を扱うことが多い
                    - その場合にコールバック関数が使われる
                        - Arrow Functionを使うことで、コールバック関数を短く簡潔に書くことができる
            - JavaScriptでのメソッド
                - オブジェクトのプロパティである関数
                    - ES2015からは、メソッドを定義する構文が追加されている
        
        **まとめ**
        
        - JavaScriptの構成
            - 式
            - 文
        - 文と式
            - 文は式になれない
            - 式は文になれる
                - 文の末尾にはセミコロンをつける
                    - ブロックで終わるぶんは例外的にセミコロンをつけなくても良い
        - JavaScriptの解釈方法
            - セミコロンがない場合に自動的にセミコロンを補完する機能がある
                - この補完機能によって意図していない挙動になる事がある
    - 条件分岐
        - JavaScriptで条件分岐を扱うためのif文やswitch文を紹介します。またネストした条件分岐が読みやすさを妨げる問題をどのように解決するかについて紹介します。
        
        **まとめ**
        
        - if文 else if else条件分岐を扱う
        - 真偽値に条件式が変化する
        - 真偽値に変換するとfalseとなる値をfalsyと呼ぶ
    - ループと反復処理
        - for文やwhile文を使った反復処理について紹介します。また、同等の反復処理がArrayのメソッドでも実現できることについても紹介します。
        
        **まとめ**
        
        - for文を使った反復処理
            - **continue文やbreak文が使用可能**
        - 配列を使った反復処理
            - continue文やbreak文が使えない
            - 一時的な変数を管理する必要がない
            - 処理をコールバック関数として書く
    - オブジェクト
        - JavaScriptのObjectはオブジェクトの基礎となるものです。オブジェクトとプロパティの作成、更新、削除などの基本的な操作について紹介します。
        
        **まとめ**
        
        - Objectというビルトインオブジェクト
        - {}でオブジェクトの生成、更新を行う
        - プロパティの確認
            - in演算子
            - `Object.hasOwn`静的メソッド
            - • Optional chaining演算子（`?.`）
                - ネストしたプロパティの存在確認
                - アクセスを同時に行う記法
            - オブジェクトのインスタンスメソッドと静的メソッド
    - プロトタイプオブジェクト
        - JavaScriptにはプロトタイプオブジェクトという特殊なオブジェクトがあります。プロトタイプオブジェクトによって、メソッドなどの特性をあるオブジェクトから別のオブジェクトへと継承しています。このプロトタイプオブジェクトによる継承の動きを紹介します。
        
        **まとめ**
        
        - オブジェクトの生成時に自動生成される
            - 例：
                - toString
        - オブジェクトはほとんどがObject.prototypeを継承しているためtoStringを呼び出せる
    - 配列
        - 配列は値を順番に格納できるオブジェクトです。この配列の作成、更新、削除などの基本的な操作や実際の使い方について紹介します。また配列における破壊的なメソッドと非破壊的なメソッドの違いについても紹介します。
        
        **まとめ**
        
        - 配列　＝＞　要素を格納できるオブジェクトの1種
        - 破壊的なメソッド
        - 非破壊的なメソッド
        - 反復処理を行う高階関数（自身を返す関数）がある
        - メソッドチェーンは配列のメソッドが配列を返す事を利用している
    - 文字列
        - 文字列リテラルを使った文字列の作成から検索や置換など基本的な文字列操作について紹介します。また正規表現と組み合わせた文字列操作やタグ付きテンプレート関数を使ったテンプレート処理などについても紹介します。
    - 文字列とUnicode
        - JavaScriptが採用している文字コードであるUnicodeと関連するStringのメソッドについて紹介します。Stringのメソッドや文字列を扱う上で、UTF-16でエンコードされていることを意識する場面について紹介します。
    - ラッパーオブジェクト
        - JavaScriptのプリミティブ型の値がビルトインオブジェクトのメソッドなどを呼び出せる仕組みとしてのラッパーオブジェクトを紹介します。プリミティブ型からオブジェクトへとどのように実行時に変換されているのかを確認できます。
        
        **まとめ**
        
        - プリミティブ型はメソッド呼び出しする事ができる
            - ラッパーオブジェクトが存在している
                - 呼び出す時に自動的にラッパーオブジェクトに変換される事で呼び出し可能
        - JavaScriptは全てがオブジェクトであるわけではない
            - オブジェクトのように扱う事が可能
    - 関数とスコープ
        - スコープという変数などを参照できる範囲を決める概念を紹介します。ブロックスコープや関数スコープなどがどのような働きをしているのか、複数のスコープが重なったときにどのように変数の参照先が決まるのかなどを紹介します。また、スコープに関係する動作としてクロージャーという性質を紹介します。
        
        **まとめ**
        
        - スコープ
            - 関数
            - ブロック
            - ネスト可能
            - 1番大きなスコープ
                - グローバルスコープ
                    - 元々、大きなスコープで囲まれている
            - スコープチェーン
                - 内側のブロックチェーンから外側へ変数の定義を探していく流れの事
                - var,functionでは巻き上げが生じる
        - クロージャー
            - 静的スコープ
            - メモリ管理
    - 関数とthis
        - JavaScriptにおけるthisというキーワードの動作を紹介します。thisの参照先は条件によって解決方法が異なるため、thisの動きについてをそれぞれの条件ごとに紹介します。一見複雑なthisの動きを予測可能にするにはどうするべきかをコード例とともに紹介します。
        
        **まとめ**
        
        - this
            - 実際にthisを実行した結果の確認
                - [What is `this` value in JavaScript](https://azu.github.io/what-is-this/)で実行する事ができる
            - thisは実行環境やコンテキストによって結果が変わる可能性があり、メソッドでないものには使うべきではない
    - クラス
        - JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。
        
        **まとめ**
        
        - プロトタイプベース
        - クラスの定義
            - クラス構文で定義する
                - プロトタイプオブジェクト
                - プロトタイプチェーン
                    - の２通りで呼び出せる
            - クラスのインスタンスにはクラスフィールドが利用可能
            - Privateクラスフフィールドを使ってアクセルを制限する事が可能
        - アクセッサプロパティはgetter,setterのメソッドでプロパティのように振る舞う
        - extendsでクラスの継承が可能
        - プロトタイプメソッドと静的メソッドはどちらも継承される
    - 例外処理
        - JavaScriptにおける例外処理について紹介します。try...catch構文の使い方やErrorオブジェクトを紹介します。またエラーが発生した際のエラー文の読み方といったデバッグ方法を紹介します。
        
        **まとめ**
        
        - try…chtch構文
            - ブロック内で発生した例外を処理する事が可能になる
            - `catch`節と`finally`節は、両方またはどちらか片方を記述する
            - `throw`文は例外を投げることができ、`Error`オブジェクトを例外として投げる
            - `Error`オブジェクトには、ECMAScript仕様や実行環境で定義されたビルトインエラーがある
            - `Error`オブジェクトには、スタックトレースが記録され、デバッグに役立てられる
        - Error Causeを使うことで、別のエラーのスタックトレースを引き継いだ新しいエラーを作成できる
    - 非同期処理:コールバック/Promise/Async Function
        - 同期処理と非同期処理の違い
            - なぜ非同期処理が重要か？
                - 非同期処理を行う方法
                    - コールバックスタイル
                    - Promise
                    - Async Function
        - 非同期処理
            - 非同期処理
                - その処理が終わる前に次の処理を評価する
                    - メインスレッドで実行でされる事もある
            - Promise
                - ES2015で導入されたビルドインプロジェクト
            - Async Function
                - 2017から導入されたビルトインオブジェクト
                    - Promiseの上に作られた構文
                        - Promiseと一緒に使う
    - Map/Set
        - データの集合を扱うビルトインオブジェクト
            - Map
            - Set
                - オブジェクトの作成方法、更新方法
                    - 実際にどのようなケースで使うのかを紹介します。
        
        **まとめ**
        
        - Map
            - キーと値の組み合わせからなるコレクションを扱うビルトインオブジェクト
                - 意図しないマッピングを避けられる
        - WeakMap
            - キーを弱い参照で持つMapと同様のビルとインオブジェクト
        - Set
            - 順序を持たないコレクションをもつビルトインオブジェクト
                - 重複する値がない事が保証されている
            - Weakset
                - 値を弱い参照で持つSetと同様のビルトインオブジェクト
    - JSON
        - JavaScriptのオブジェクトリテラルをベースに作られたデータフォーマット
            - JavaScriptからJSONの読み書きをするビルトインオブジェクトの使い方を紹介します。
        
        **まとめ**
        
        - JSのオブジェクトリテラル{}を元に作られた軽量なデータフォーマット
            - シリアライズ
                - JSONの中にはシリアライズ不可なオブジェクトもある
                    - JSON.stringifyはシリアライズ対象のtoJsonメソッドを利用する
            - デシリアライズ
    - Date
        - 日付や時刻を扱うビルトインオブジェクトのDateを紹介します。
        
        **まとめ**
        
        - Dateオブジェクトのインスタンス
            - 特定の時刻を表すビルトインオブジェクト
        - 時刻の定義
            - UTC（協定世界時）の1970年1月1日0時0分0秒を基準
                - 相対的なミリ秒として保持されている
        - DateコンストラクタでDateインスタンスを作成する事ができる
        - 単体だとユースケースでは使う事が難しい
            - ライブラリと一緒に使う事が一般的
    - Math
        - 数学的な定数や関数を提供するビルトインオブジェクト
        
        **まとめ**
        
        - Mathはコンストラクタではない
            - インスタンス化する事ができない
    - ECMAScript
        - JavaScriptの仕様であるECMAScriptについて
            - ECMAScriptの歴史や仕様策定がどのようなプロセスで行われているかを紹介します。
        
        まとめ
        
        - JS
            - ECMAScript
            - ウェブブラウザ
            - Node.js
            - WebAssembly
            - WebGL
            - WebRTC
                - 全てを知る事は難しいため知らなくてOK
                    - ただ、過程があるという事
                    - 疑問を持った時には調べる事ができるようになる事が重要
        - ECMAScriptモジュール
        JavaScriptのモジュール（ECMAScriptモジュール）について紹介します。
    - 第一部: 終わりに
        - 第2部でやる事：
            - 1部で学んだ基本文法を使ってアプリケーションを作成する
            - ブラウザ固有のAPI、ライブラリを見る
        - 文法
            - Proxy、Reflect
                - プロパティの取得、代入に対して独自の動作を定義する事ができる
        - 調べ方
            - APIについて
                - MDN Web Docsというリファレンスに大部分が載っている
                    - 実質的な公式レファレンス
- 第2部
    - アプリケーション開発の準備
        - Node.jsのLTS版をインストールした
        - npmとnpxでモジュールのインストールと実行をした
        - `@js-primer/local-server`モジュールを使ってローカルサーバーを起動して終了した
    - Ajax通信
        - エントリーポイントの作成
            - このセクションでは、エントリーポイントとなるHTMLを作成
                - JavaScriptモジュールのエントリーポイントとなるJavaScriptファイルを読み込む
            - `ajaxapp`という名前のプロジェクトディレクトリを作成した
            - エントリーポイントとなる`index.html`を作成した
            - JavaScriptのエントリーポイントとなる`index.js`を作成し`index.html`から読み込んだ
            - ローカルサーバーを使ってブラウザで`index.html`を表示した
            - `index.js`からコンソールに出力されたログを確認した
            - JavaScriptからHTMLドキュメントを操作するDOMについて学んだ
        - HTTP
            - [Fetch API](https://developer.mozilla.org/ja/docs/Web/API/Fetch_API)を使ってHTTPリクエストを送った
            - GitHubのAPIから取得したユーザー情報のJSONオブジェクトをコンソールに出力した
            - Fetch APIの呼び出しに対するエラーハンドリングを行った
            - `fetchUserInfo`関数を宣言し、ボタンのクリックイベントで呼び出した
        - データを表示する
            - [テンプレートリテラル](https://jsprimer.net/basic/string/#create)を使ってHTML文字列を組み立てた
            - `innerHTML`プロパティを使ってHTML文字列をDOMに追加した
            - [タグつきテンプレート関数](https://jsprimer.net/basic/string/#tagged-template-function)を使ってHTML文字列をエスケープした
            - `fetchUserInfo`関数を呼び出し、HTMLにユーザー情報が表示されることを確認した
        - Promiseを活用する
            - HTMLの組み立てと表示の処理を`createView`関数と`displayView`関数に分離した
            - `main`関数を宣言し、`fetchUserInfo`関数が返すPromiseのエラーハンドリングを行った
            - Promiseチェーンを使って`fetchUserInfo`関数をリファクタリングした
            - [Async Function](https://jsprimer.net/basic/async/#async-function) を使って`main`関数をリファクタリングした
            - `index.html`に`<input>`タグを追加し、`getUserId`関数でユーザーIDを取得した
    - Node.jsでCLIツールを作成する
        - Hello world
            - `nodecli`ディレクトリを作成した
            - `nodecli/main.js`ファイルを作成した
            - `node`コマンドで`nodecli/main.js`を実行し、標準出力にログが出力されるのを確認した
            - `npm init --yes`コマンドで`nodecli/package.json`ファイルを作成した
            - グローバルオブジェクトについて、ウェブブラウザとNode.jsで実行環境による違いがあることを理解した
        - コマンドライン引数を設定する
            - `process.argv`配列に`node`コマンドのコマンドライン引数が格納されていることを確認した
            - ECMAScriptモジュールを使ってパッケージを読み込めることを確認した
            - `node:util`モジュールの`parseArgs`関数を使ってコマンドライン引数をパースできることを確認した
            - コマンドライン引数で渡されたファイルパスを取得してコンソールに出力できた
        - ファイルを読み込む
            - `node:fs/promises`モジュールの`readFile`関数を使ってファイルを読み込んだ
            - UTF-8形式のファイルの中身をコンソールに出力した
            - `readFile`関数の呼び出しにエラーハンドリング処理を記述した
        - MarkDownファイルをHTMLへ変換する
            - markedパッケージを使ってMarkdown文字列をHTML文字列に変換した
            - コマンドライン引数でmarkedの変換オプションを設定した
            - `-gfm`フラグを使って、Markdownの変換結果が変わることを確認した
        - ユニットテストを記述する
            - Markdownの変換処理をECMAScriptモジュールとして`md2html.js`に切り出し、`main.js`から読み込んだ
            - `npm test`コマンドで`node --test`が実行できることを確認した
            - `md2html`関数のユニットテストを作成し、テストの実行結果を確認した
    - Todoアプリケーションを作る
        - エントリーポイント
            - `todoapp`という名前のプロジェクトディレクトリを作成した
            - エントリーポイントとなる`index.html`を作成した
            - JavaScriptのエントリーポイントとなる`index.js`を作成し`index.html`から読み込んだ
            - ローカルサーバーを使って`index.html`を表示した
            - `src/App.js`を作成し、`index.js`から`import`文で読み込めるのを確認した
        - アプリケーションの構成要素
            - 実装するTodoアプリの構成要素を理解した
            - HTML、CSS、JavaScriptの役割の違いを理解した
            - Todoアプリの見た目をHTMLとCSSで定義した
        - Todoアイテムの追加を実装する
            
            チェクリスト
            
            - フォームの送信を`submit`イベントで受け取り、入力内容を確認した
            - HTML文字列からHTML要素を作成する`html-util.js`を実装した
            - フォームからTodoアイテムを追加した
            - Todoアイテムの追加に合わせてTodoアイテム数を更新した
            
            このセクションで、TodoアプリにTodoアイテムを追加する機能が実装できました。
            
            - Todoアイテムを追加できる
            
            Todoアプリに実装する残りの機能は次のとおりです。
            
            - Todoアイテムの完了状態を更新できる
            - Todoアイテムを削除できる
        - イベントとモデル
            - 直接DOMを更新する問題について理解した
            - `EventEmitter`クラスでイベントの仕組みを実装した
            - TodoリストとTodoアイテムをモデルとして実装した
            - `TodoListModel`を`EventEmitter`クラスを継承して実装した
            - Todoアイテムの追加の機能をモデルを使ってリファクタリングした
        - Todoアイテムの更新と削除を実装する
            - Todoアイテムの完了状態として`<input type="checkbox">`を表示に追加した
            - チェックボックスが更新されたときの`change`イベントのリスナー関数でTodoアイテムを更新した
            - Todoアイテムを削除するボタンとして`<button class="delete">x</button>`を表示に追加した
            - 削除ボタンの`click`イベントのリスナー関数でTodoアイテムを削除した
            - Todoアイテムの追加、更新、削除の機能が動作するのを確認した
            
            このセクションでTodoアプリに必要な要件が実装できました。
            
            - Todoアイテムを追加できる
            - Todoアイテムの完了状態を更新できる
            - Todoアイテムを削除できる
        - Todoアプリケーションのリファクタリング
            - Appから表示に関する処理をViewコンポーネントに分割した
            - Todoアプリの機能と対応するリスナー関数を`App`クラスのメソッドへ移動した
            - Todoアプリを完成させた
    - このTodoアプリケーションで実装できていない事
        - 空の投稿を防ぐ事
        - ライフサイクル処理
            - on関数関連
    - アプリケーションのまとめ
        - JSで作られる代表的なアプリケーションとしてTodoアプリがある
            - 今回はライブラリを使用しない
                - 実務では確実にライブラリを使う
                    - しかし、ライブラリも基礎の上に立つものである事を忘れないようにする

