- 学習ソース
  - progate
    - https://prog-8.com/courses/es6
  - JavaScript primer
    https://ja.m.wikibooks.org/wiki/JavaScript/void#:~:text=void%20%E3%81%AF%E3%80%81JavaScript%20%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89,%E6%89%8B%E6%AE%B5%E3%81%A8%E3%81%97%E3%81%A6%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82
- **_JavaScrip の概要_**
  - Java Script って何？
    - 主に Web ブラウザの中で動くプログラミング言語
      - 動的型付け言語(インタプリンタ言語)である
    - Web アプリケーションにおいてクライアントサイドでもサーバーサイドでも動作する言語
      - 動的なページを作るのに必須になっている
        - 操作に応じて表示が変わる
        - データの取得
          - Web サーバーと通信を行う
        - データの更新
      - html と css のみではできない事をしている
    - 現在の Web サイトには欠かせない存在になっている
      - Web アプリケーション　＝＞　 Web アプリケーションのように動く Web サイト
    - JavaScript は Node.js でも使用されている
      - デスクトップアプリ
      - スマートフォンアプリ
      - IoT デバイス
        - などでも使用することができている
    - 元々、Netscape Navigator というブラウザ向けに開発された言語
      - 影響を受けた言語
        - C
        - Java
        - Self
        - Scheme
      - 大部分がオブジェクトで構成される
        - オブジェクト同士の関係性で成り立っている
          - オブジェクトの種類
            - ECMAScript の仕様で定められたオブジェクト
            - 実行環境が定義したオブジェクト
            - ユーザー（自分）が定義したオブジェクト
  - ランタイムシステム
    - Node.js
      - V8 エンジンを使って JavaScript をサーバーサイドでも使えるようにしたもの
        - API やライブラリを提供する
    - DENO
      - JavaScript と TypeScript の実行環境を提供する
    - BUN
      - JavaScriptCore エンジンを使用する
  - ランタイムエンジン
    - V8 エンジン　＝＞　 Google が開発　＝＞　高速な実行環境
    - SpiderMonkey
    - JavaScriptCore
    - Chakra
    - Nashorn
  - ECMAScript
    - 仕様
      - どの実行環境でも共有の環境
        - JavaScript はこの ECMAScriptn によって仕様が決まっている
          - JS・TS が準拠する仕様
    - JS と ECMAScript の関係
      - 仕様を定義する
        - 仕様　＝＞　決まりごと
          - ブラウザが JS を読み込んだ時にどのように解釈するのか？
            - 処理がどのように動くのか？という事を定義する
      - 歴史
        - JS を標準化するべく ECMAScript が策定された
          - JS は Netscape 社が開発した言語
            - Netscape 社は JS を標準化するために国際規格策定団体 Ecma インターナショナルに依頼する
              - その結果
                - Ecma によって標準化された JavaScript は ECMAScript と呼ばれる事になっている
      - JS が従うべき仕様
        - ECMAScript が JS がどのように振る舞うかを定義している
          - JS の実装　＝＞　 ECMAScript の実装と呼ばれる事もある
      - 命名由来
        - 競争関係だった Netscape 社と Microsoft 社
          - ECMAScript が合意できる妥協案だった説
            - Netscape 社 => JavaScript
            - Microsoft 社 => JScript
        - JavaScript という言葉が商標だった事
          - JavaScript は当時 Sun が所有する商標だった
            - 現在は orakle 社が保有
    - JavaScript の仕様は毎年更新される
      - ECMAScript は毎年更新される
        - JavaScript には新しい構文や機能が増え続ける
          - ECMAScript は後方互換性に優れる
            - 学びは無駄にならない
    - 仕様改訂のステップ
      - ステージ 条件
        - 0 **Strawperson** なし
        - 1 **Proposal** チャンピオン(委員会の改定推進パートナー)が決まっている
          - 課題と解決策を説明したリポジトリが公開されている
            - デモがあるとよい
        - 2 **Draft** ECMAScript の仕様記述言語で主要な部分の仕様が書かれていること
        - 3 **Candidate** 完全な仕様書があること。レビュアと ECMAScript 編集者の署名があること
        - 4 **Finished** 2 つ以上の JS エンジンに実装が存在していること。
          - ECMAScript へプルリクエストが送信されている
            - ECMAScript 編集者に承認されていること
    - ECMAScript とブラウザの関係
      - ECMAScrip が決めるクライアントサイドの JS は部分的
        - ECMSScript は主に
          - 言語の文法、構文の解釈方法、コアの API など言語の中核部分を決める
            - 関数宣言の書き方はこういう文法になる
            - 変数が宣言されたとき、JavaScript エンジンはこういう動作になる
            - String や Array オブジェクトにはこういうメソッドがある
      - JS におけるブラウザ仕様を決める団体 => 標準化団体 WHATWG
        - HTML Living Standard
          - window オブジェクト
          - HTMLDivElement
          - ローカルストレージなどの API
      - ブラウザ内部は様々な部品で分ける事ができる
        - レンダリングエンジン
          - JS エンジンを組み込んだブラウザの表示機能を担うモジュール
            - JS のみならず HTML や CSS も解釈して総合的に画面表示をする
              - Blink
                - V8 エンジンを JS エンジンに採用
              - Gecko
              - WebKit
        - JavaScript エンジン
          - ECMAScript を実装したモジュール
            - V8
            - SpiderMonkey
            - JavaScriptCore
        - レンダリングエンジンは変更される事や環境に応じて変わる
          - ios のエンジンは WebKit と独占的に利用を許されている
            - 同じサービスでも環境に応じて変化する
        - エンジニアはエンジンについて理解する事が重要 - 普段、コードを書くエンジニアはエンジンについて理解する事が重要である - エンジンについて理解する事　＝＞　実行環境ついて理解する事 - テストなど、バグに関して基本的には ECMAScript に準拠するエンジンでも少しの違いなどが出てくる可能性がある
          ![alt text](https://typescriptbook.jp/img/overview/ecmascript/browser-rendering-engine-javascript-engine-ecmascript-relations.svg)
    - JS における仕様決定の棲み分け
      - モジュール
        - ECMAScript
          - import や export の構文や、モジュール内部の仕様
        - HTML Living Standard
          - import "指定子"
  - Ecma インターナショナル
    - 情報通信技術のさまざまな国際規格を策定している
      - 各規約には番号が振られている
        - ECMAScript の規格番号 => ECMA-262
      - 様々な専門委員会
        - 委員会の名称　＝＞　 TC39
  - JS のバージョン
    - ES2015（ES6)
      - JS は現在、Web 開発において必須の存在となっている
        - 旧バージョンの JS5→ 新バージョン ES2015（ES6)
          - 旧バージョンよりも効率的にコードを書く事ができるようになったコード
  - scrict mode
    - 厳格な実行モード
      - 古く安全でない機能や構文が 1 部禁止される
        - use strict という文字列を関数 or ファイルの先頭に記載するとそのスコープでは strict mode が実行される
          - module の実行コンテクストではデフォルトになっている
            - 禁止される例：
              - eval
              - with
                - 上記のようなレガシーな構文を禁止する
                  - 明らかな問題を含んだコードに対しては早期に例外を投げる事で開発者が間違いを気づくようにする
  - 実行コンテクスト
    - Script
      - デフォルトが strict mode ではない
    - Module
      - デフォルトが strict mode になっている
        - Module の実行コンテクストでのみ実行される
  - 大文字と小文字を区別する
    - neme と NAME は違う言語として認識される
  - 予約語を持つ言語
    - 特別な意味を持つキーワード
  - 文と式
    - JavaScript のソースコードを構成する文と式という構文的な概念について
      - 文と式の違いを理解する
        - どの場合にセミコロンを入れるかがわかるようになる
    - 文（Statement）毎に処理し、文末は;（セミコロン）で区切る
      - 特殊なルールでセミコロンがないぶんも自動的にセミコロンが代入される仕組みがある
        - 暗黙的な仕様に頼る事は進められない
    - 式　＝＞　値を生成し、変数に代入できるもの
      - 式の特徴として、式を評価すると結果の値を得る事ができるもの
        - 結果の値　＝＞　評価値
      - 42 や foo など
        - 1 + 1 　というものもそうなる
    - 文　＝＞　処理する 1 ステップが 1 つの文
      - if 文や for 文など
    - 式文
      - 式は文になる事ができる
        - 文になった式を式分と呼ぶ
          - 文が書ける場所には式が書ける
    - ブロック文
      - {}で囲んだ範囲には複数の文を記載する事ができる
        - if 文や for 文などの構文と組み合わせて使用する事が多い
          - 単独でも記載する事ができる
            - 例外としてブロックの末尾には;セミコロンが必要ない
    - 関数宣言（文）と関数式
      - どちらも function というキーワードを利用する
        - 文と式の違い
          - 関数宣言文にはセミコロンがなし
          - 関数式にはセミコロンがある
            - この差分はブロックで終わるか？式なのか？で変わる
  - データ型
    - JS は動的型付け言語のため静的型付け言語のような変数の型はない
      - しかし、文字列・数値・真偽値といった値の型は存在する
    - プリミティブ型　＝＞　基本型
      - イミュータブルな値という特性を持っている
        - 文字列であっても一度、作成したら変更できないイミュータブルの特性を持つ
      - 真偽値（Boolean）
        - true または false のデータ型
      - 数値（Number）
        - 42 や 3.14159 などの数値のデータ型
      - 巨大な整数（BigInt）
        - ES2020 から追加された 9007199254740992n など
          - 任意精度の整数のデータ型
      - 文字列（String）
        - "JavaScript" などの文字列のデータ型
      - undefined
        - 値が未定義であることを意味するデータ型
      - null
        - 値が存在しないことを意味するデータ型
      - シンボル（Symbol）
        - ES2015 から追加された一意で不変な値のデータ型
    - オブジェクト型
      - 複数のプリミティブ型 or オブジェクトからなる集合
        - 作成した後も値を変更する事ができる
          - 値の変更というものは値自体を変更するのではなく、値の参照を変更するという事になる
      - プリミティブ型以外のデータ
        - オブジェクト、配列、関数、クラス、正規表現、Date
  - 文字列という概念(エンコード)
    - 普段からなにげなく使用している文字列だが、コンピューターは文字列をそのまま認識できない
      - 文字から符号に変換する必要がある
        - 符号化(エンコード)
          - 特定の文字に対応する ID の一覧表 => 符号化文字集合
            - Unicode => 符号化文字集合からカタカナの一部分を取り出したもの
        - ECMAScript においては、
          - 文字コード　＝＞　 Unicode を採用する
          - エンコード　＝＞　 UTF-16
            - Code Unit(符号単位)が 16 ビットになる仕様
              - 文字列を構成する UTF-16 の Code Unit との関係性は
                - インデックス
                - Code Unit
                - 実際に出力したい文字列が示される
  - サロゲートペア
    - Unicode における code point を 16 ビットで表現する際に現れる上限
      - Unicode を表現すると code point は 10 万種類を超える
      - その code point を 16 ビットで表現するの gCode Unit になる
        - しかし、16 ビットで表現できる範囲は 65536 種類（2 の 16 乗）になるため表現できない範囲が出てくる
          - その時にサロゲートペアとして扱う
      - 2 つの Code Unit の組み合わせ（合計 4 バイト）で 1 つの文字（1 つの Code Point）を表現する
        - 2 つのサロゲートペアを使って一つの code point を表現する
          - console.log("\uD83C\uDF4E"); // => "🍎"
            - サロゲートペアで表現する際にインデックスアクセスを実施する場合には別々のものとして表現されるようになる
              - 上位サロゲート（0 番目）と下位サロゲート（1 番目）
            - length メソッド
              - length メソッドを使った際にも code unit 毎の判別になるため 2 という結果になる
  - code point を扱う
    - code point => unicode において文字列に対して 16 進数でそれぞれ一意のコードが振られたもの
      - u フラグ
        - code point を扱うためのメソッドが用意されている
          - 特に意識せずに正規表現における.などを使用して code point を扱おうとすると code unit が並んでいると判別されてしまい望んでいた結果ではないものが帰ってきてしまう
            - そこで u フラグを使うことで code point を意識して正規表現などを使うことが可能になる
              - 基本的には u フラグをつけて問題になる事は少ない
                - サロゲートペアの片方だけを取得したいという要件は非常に稀であることが予想されるからである
      - code point の数を数える
        - String の length プロパティは code unit を判別するため code point を扱いたい時にそのまま使ってしまうと見た目よりも誇張された結果が出てしまう
          - code point を扱いたい場合はまずは code point に区切った配列に形を変える
          - 形を変えた配列を数えるという方法を取る
            - Symbol.iterator という特別なメソッドが搭載された iterable オブジェクトは iterable なオブジェクトと呼ばれる
              - Array.from 静的メソッドはその特別なオブジェクトを返すメソッドで for...of を使うことが出来るメソッドになっている
                - 文字列 => iterable オブジェクト
                  - Array.from 静的メソッドによって 1 文字（厳密には Code Point）ごとに区切った配列に変換する事ができる
                    - 注意点：このように適切な形ん変更した後も見た目と違った結果が出てくる事がある。それは、見えていない区切り文字なども表現するため工夫がさらに必要な場合もある
      - code point に対する反復処理
        - 適切な形に変換した後に length プロパティを使って要素数を数えて繰り返し処理を実行する方法
        - for...of を使う方法
          ```JavaScript
          // 指定した`codePoint`の個数を数える
          function countOfCodePoints(str, codePoint) {
              let count = 0;
              for (const item of str) {
                  if (item === codePoint) {
                      count++;
                  }
              }
              return count;
          }
          console.log(countOfCodePoints("🍎🍇🍎🥕🍒", "🍎")); // => 2
          ```
  - 文字列と unicode を扱う際に注意するべき点
    - JavaScript と Unicode はそれぞれ独立した組織なため諸問題がある
      - JavaScript には文字列に対する優れたメソッドがある一方で絵文字などが多様される現代において問題が解決されていない
        - 特に Java も JavaScript と同じ UTF-16 でエンコードを行っているため同様の問題が起きやすい
          - もし、特定の問題にぶつかった場合には他の言語ではどのように対処されているか見てみるもの必要と考えられる
- **_JavaScript の仕様_**

  - 空白の扱い
    - 空白は個数が変わっても認識は変わらない
  - 出力 => 文字リテラルを使って作成する
    - console.log("○○");
      - ("○○");内の ○○ を出力する事ができる
        - ()内の文字列は” or ’ のどちらかで囲む必要がある
        - 文末の;は必須ではないが記載する方が好ましい
  - コメントアウト
    - JavaScript におけるコメントの書き方
      - コメントはプログラムとして評価されない
        - ソースコードに対する説明を書くために利用する
    - １行のみのコメントアウト
      - //以降から行末までがコメントアウトされる
    - 範囲でのコメントアウト
      - /_から_/までの範囲がコメントアウトされる
    - HTML-like コメントは後方互換性のためだけに存在する
  - 計算
    - 数値の計算
      - クウォーテーションは無しで計算式を記載する
        - console.log(3+4);
      - 掛け算「\*」
      - 割り算「/」
      - 余りの計算「%」
    - 省略した記載方法（省略形）
      - X = X + 10 → X += 10
      - X= X - 10 → X -= 10
      - X= X _ 10 → X _= 10
      - X= X / 10 →X /= 10
      - X= X % 10 → X %= 10
    - 文字列の連結
      - 連結させたい文字列同士を記号”＋”で囲む
        - 「"にんじゃ" + "わんこ"」→「"にんじゃわんこ"」
    - 文字列の連結と数値の計算の違い
      - 数値をクウォーテーションで囲んで記載すると計算されずに文字列として認識されて出力される
        - console.log(”3+4”);
    - ”＝”の意味
      - 等しいという意味ではなう右辺を左辺に代入するという意味
  - 変数の宣言（全て共通）
    - 変数同士を,（カンマ）で区切る
      - 同時に複数の変数を定義できる
    - 変数の宣言規則
      - 半角のアルファベット
      - \_（アンダースコア）
      - $（ダラー）
      - 数字
        - これらを組み合わせた名前にする
    - 変数名は数字から開始できない
    - 予約語と被る名前は利用できない
  - 変数（let）
    - データ（値）の入れ物（箱）
      - 箱の名前が”変数名”
    - let は初期値を指定しない変数も定義する事ができる
      - 初期値が指定されない変数は undefined で初期化される
    - なぜ変数を使用するのか？
      - 繰り返し使う事ができる
        - 例：同じ処理を複数回使いたい場合
          - A さん＋”おはようございます”
          - B さん＋”おはようございます”
            - ”おはようござます”を変数で定義しておけば繰り返し使える
      - 変更に対応しやすい
        - 変更箇所が少ない
          - 例:上記のような繰り返し同じ処理がある場合にも変数を定義していれば変数の値を変更する事で全体に変更がかかる
      - 値の意味がわかりやすい
        - 可読性が高くなる
    - 変数の定義
      - let でこれから変数名を定義しますという宣言になる
        - let 変数名 = 値
    - 変数の上書き
      - 定義された変数は変数名=上書きする内容とする事で再定義する事ができる
        - 変数名＝上書きする値
    - 変数の更新
      - 変数は変数自身に付け加えて更新する事もできる
        - let number = 5;
        - number = number+5;
          - 更新した値は更新した値が保持される
    - 変数の命名ルール
      - ES6 での命名ルール
        - 良い例
          - 英単語を使用する
            - name
          - 2 単語になる場合には大文字で区切る
            - firstName
        - 悪い例
          - 数字開始
            - エラーになってしまう
          - 日本語
            - 望ましくない
          - ローマ字
            - 望ましくない
    - 変数の使用
      - 変数の定義を行い定義した変数に対して文字列などデータを代入する事で変数名を呼び出した際に代入したデータが出力される
        - 変数を呼び出す時にはクウォーテーションで囲まないという事に注意する
      - 変数は代入されているデータに応じて計算・連結する事ができる
        - 文字列の場合
          - 変数に代入されていない文字列同様に使用する事ができる
        - 数値の場合
          - 変数に代入されていない数値同様に計算などの処理を行う事ができる
  - 定数に近い変数を定義できる宣言(const)
    - 定数の定義
      - 一度、定義すると毎回同じ値を返す
    - const
      - const は定数ではない
        - const は再代入禁止の変数なのであってオブジェクトの値をプロパティを介して変更する事ができる
      - 再代入禁止の変数
        - その変数が参照する値を定義する
          - 再代入する必要がない場合に優先的に使用される変数
            - 再代入が必要な場合には let を使う
      - 実質的に的に
  - 変数（var）
    - let と同じように使う事ができる変数
    - let と const との違い（問題点）
      - 同じキーワードに対して再代入できてしまう点
        - 変数の上書きをしても構文エラーが起きない
    - 問題が出現したため新しく const と let が追加された
      - var 自体を改善しなかった理由
        - 後方互換性
  - 値の評価と表示
    - 変数の宣言をする事で値に名前をつける事ができる
      - 変数の宣言は返り値はない
  - 実行環境
    - ブラウザの違いや実行環境によってコードが動いた結果が変わる事がある
  - REPL（read–eval–print loop）
    - ブラウザには Web コンソールという試したいコードを実行するツールがある
      - 変数の宣言をした結果は undifined が帰ってくる
        - 変数の宣言は戻り値を持たない
          - 変数を呼び出すと値が返ってくる
    - リロードするまで変数の宣言などが保たれる
      - 再定義などにはエラーが起きてしまった場合にはリロードする
  - JavaScript を読み込む方法
    - Web サイトは HTML で表示される
      - HTML で JavaScript を読み込む事で JavaScript を実行する事ができる
  - リテラル
    - リテラルを使う事で簡単に定義する事ができる
      - 構文として定義されたもの
    - リテラル表現があるプリミティブ型とオブジェクト型
      - プリミティブ型
        - 真偽値
          - true; false;
            - 見た目通りに真偽値を示す
        - 数値
          - 64 ビットで数値を表現する
            - 54 ビットを数字の格納
            - 11 ビットを小数点の位置に使う
            - 1 ビットをプラスとマイナスに使う
          - 整数リテラル
            - 10 進数　＝＞　数値
            - 2 進数　＝＞　ビット演算
            - 8 進数　＝＞　ファイルのパーミッションなど
            - 16 進数 ＝＞　コードポイントや RGB 値など
          - 浮動小数点リテラル
            - ドットを含んだ数値
            - e または E を含んだ数値
              - 0 から始まる浮動小数点は 0 を省略して記載する事ができる
                - JS は.から始まるオブジェクトが多いため省略せずに記載する方が望ましい
        - BigInt
          - 数値リテラルが扱う事ができる値は決まっている
            - 上限を超えると正しい結果にならない可能性がある
          - 数値リテラル　＝＞　 64 ビット
          - Bigint ＝＞　任意の精度の整数
            - 扱う事ができる整数の範囲が大きくなる
        - 文字列
        - null
      - オブジェクト型
        - オブジェクト
        - 配列
        - 正規表現
          - /スラッシュとスラッシュ/で正規表現のパターン文字を囲む
            - +や/で始まる特殊な文字が出現する
    - "（ダブルクォート）と'（シングルクォート）
      - 両者の意味的な違いは基本的にはない
        - こーでょング規約などによって異なる
          - 改行をそのまま入力する事はできず、JS エンジンが解析できないので構文エラーになってしまう。
    - テンプレートリテラル
      - 文字列中に改行を入力できる
        - テンプレートリテラルを使って複数行の文字列を見た目どおりに定義できる
    - リテラルに共通するエスケープ
      - リテラルと同じ記号が出現した場合
        - \（バックスラッシュ）を使いエスケープする必要がある
    - エスケープシーケンス
      - \（バックスラッシュ）と特定の文字を組み合わせる事で表現する事が出来る
        - \から始まる文字は自動的にエスケープシーケンスと呼ばれる
          - \を無視して意図しない結果になる可能性がある
            - \\と表現する
    - テンプレートリテラル
      - ${定数}とする事で文字列内に変数を埋めこむことができる
        - テンプレートリテラルを使用する場合には文字列全体をバッククォーテーション（`）で囲む必要がある
  - 文字へのアクセス
    - 文字列の特定の位置にある文字はインデックスを使って指定しアクセスする事ができる
      - console.log(str[0]);
        - 存在しないインデックスにはアクセスする事はできない
    - String.prototype.at
      - console.log(str.at(0));
        - -1 などとすると末尾から数えた位置の文字にアクセスする事が出来る
  - 条件分岐
    - if 文（条件分岐）
      - ある条件が true の場合には実行する文の処理を行う
        - もし ○○ ならば ●● を行うという処理を作ることができる
          - if (条件式) {処理内容}　 ←；は必要なし
            - 処理の内容を記載する{}は実行する文が一行のみの場合には必要ない
              - if 文の範囲がわからなくなってしまうため常に囲む事を勧められる
      - if 文を書く際には中の処理内容はインデントする事を意識する
      - if 文はネストする事ができる
        - if 文の中にさらに if 文を入れる事ができる
          - ネストする if 文の例：
            - うるう年かを判定する
              - 西暦で示した年が 4 で割り切れる年はうるう年です
              - ただし、西暦で示した年が 100 で割り切れる年はうるう年ではありません
              - ただし、西暦で示した年が 400 で割り切れる年はうるう年です
                - この 3 つの条件が満たされるものがうるう年となる
      - 真偽値
        - if 文は検証の結果を true or false の 2 つで返す
          - 真　＝　 true
          - 偽　＝　 false
            - falsy な値
              - undefined
              - null
              - 0
              - 0n
              - NaN
              - ""（空文字列）
      - else
        - if 文の真偽値が true 以外の場合に行う処理　＝＞　条件に一致しなかった場合
          - 「もし〇〇なら ●● を行う、そうでなければ ■■ を行う」という処理
            - if (条件式){true だった場合の処理内容}else{true 以外だった場合の処理内容}
      - else if (条件)
        - if 文が true 以外だった場合にさらに条件を加える際の記載方法
          - 3 つの条件分岐するプログラムを作る事ができる
          ```jsx
          if (条件1) {
            条件１がtrueだった場合に実行する処理内容;
          } else if (条件1がtrue以外だった場合の条件2) {
            条件2がtrueだった場合の処理内容;
          } else {
            条件2がtrue以外だった場合の処理内容;
          }
          ```
      - かつ・または
        - かつ →&&
          - 条件 1&&条件 2 は条件 1 かつ条件 2 という意味になる
            - 条件全てが true であれば true になる処理
        - または → ｜｜
          - 条件 1 || 条件 2 は条件 1 または条件 2 という意味になり
            - 条件のいずれかが true であれば true を返す処理
    - switch 文　 if 文以外の条件分岐
      - 式の評価結果によって処理を分岐する方法
        - switch(条件の値){ 処理 }
          - case 値 1: break;
            - case と値が一致した場合には case で定義した処理を実行する
              - case の分だけ条件分岐を設定できる
                - break を記載する事で条件分岐の終了を定義して次の case の条件分岐に移行する事ができる
        - 処理の流れ
          - まず、条件部分を評価する
            - 条件部分の評価に応じて case で定義した値が評価結果と**厳密に等しいか？**を判別していく
        ```jsx
        const name = "kouki";
        switch (name) {
          case 値１:
            値１が条件と等しい場合に実行される処理;
            break;
          case 値２:
            値２が条件と等しい場合に実行される処理;
            break;
        }
        ```
      - switch 分の case どれにも当てはまらなかった場合
        - default を設定する
          - default: 処理 break;
  - 演算子
    - 2 項演算子 => 2 つのオペランドに対する処理を行う
      - プラス演算子（+）
        - 2 つのオペランドである数値を加算する演算子
          - 整数と浮動小数点どちらも IEEE 754 方式が採用されている
            - どちらも加算する事ができる
      - マイナス演算子（-）
        - 2 つのオペランドである数値を減算する演算子
      - 文字列結合演算子（+）
        - 2 つのオペランドである文字列を結合する演算子
      - 乗算演算子（\*）
        - 2 つのオペランドである数値を累乗する演算子
      - 除算演算子（/）
        - 2 つのオペランドである数値を徐算する演算子
          - ０を徐算した場合には無限大を示す Infinity となる
      - 剰余演算子（%）
        - 2 つのオペランドである数値を徐算したあまりを求める演算子
          - 左オペランドを右オペランドで徐算したあまりを求める
      - 大小を比べる演算子(比較演算子)
        - <
          - 左辺は右辺より小さい
        - <=
          - 左辺が右辺より小さい、もしくは等しい
        - >
          - 左辺は右辺より大きい
        - > =
          - 左辺は右辺より大きい、もしくは等しい
      - 等価演算子
        - ==
          - 左辺と右辺が等しければ true
            - 文字列の演算
              - Code Unit が同じ順番で並んでいるか？
              - 文字列の長さは同じか？
        - !=
          - 左辺と右辺が異なれば true
        - 注意点
          - 数値「12」と文字列「"12"」はデータの扱い上、文字列と数値となり異なるが、等価演算子においては文字列の 12 を数値の 12 に変換して処理しているため等しいものとして扱われる
      - べき乗演算子（\*\*）
        - 2 つのオペランドである数値をべき乗する演算子
          - 左オペランドを右オペランドでべき乗した値を返す
            - 同じ役割を持つ、Math.pow メソッドが存在する
      - 厳密等価演算子
        - ===
          - 右辺と左辺が厳密に等しい
        - !==
          - 右辺と左辺が厳密に異なる
        - 厳密等価演算子においては数値「12」と文字列「"12"」は異なるものとして扱われるようになる。
        - 基本、理由がなければ厳密等価演算子を使用するようにする
    - 単項演算子 => 1 つのオペランドを受け取る演算子
      - 単項プラス演算子（+）
        - オペランドを数値に変換する
          - 文字列を数値に変換する
            - 数値に変換する事ができない文字列などは NaN という特殊な値に変換される
              - NaN => Not-a-Number の略称
      - 単項マイナス演算子（-）
        - マイナスの数値を表す場合に利用する
      - デクリメント演算子
        - オペランドの数値を-1 する演算子
      - インクリメント演算子（++）
        - オペランドの値を+1 する演算子
          - 前置インクリメント演算子
            - 演算してから状態を評価する
          - 後値インクリメント演算子
            - 演算前のオペランドの状態を評価
            - その後に演算を実行する
            - 最終結果としてはインクリメントされる
    - ビット演算子
      - オペランドである数値を符号付き 32 ビット整数として扱う
        - 1 => 00000000000000000000000000000001
          - 先頭の最上位ビットは符号を示す
        - 0 => 正の値
        - 1 => 負の値
      - -1 の符号付き 32 ビット整数
        - 0000_0000_0000_0000_0000_0000_0000_0001 => 10 進数の 1

          ↓

        - 1111_1111_1111_1111_1111_1111_1111_1110 => 反転したビット
        ↓
        - 1111_1111_1111_1111_1111_1111_1111_1111 => 1 ビットを足す
      - ビット論理積（&）
        - ビットごとの AND 演算した結果を返す
      - ビット論理和（|）
        - ビットごとの OR 演算した結果を返す
      - ビット排他的論理和（^）
        - ビットごとの XOR 演算した結果を返す
      - ビット否定（~）
        - オペランドの各ビットを反転した値を返す
      - 左シフト演算子（<<）
        - bit の数だけ左にシフトする
      - 右シフト演算子（>>）
        - bit の数だけ右へシフトする
      - ゼロ埋め右シフト演算子（>>>）
        - 数値である num を bit の数だけ右へシフトするのは右シフト演算子（>>）と同じ
          - 異なる点は右にあふれたビットは破棄されて 0 のビットを左から詰める
      - Nullish coalescing 演算子(??)
        - 左辺の値が nullish であるなら、右辺の評価結果を返す。
          - nullish とは、評価結果が null または undefined となる値のこと
    - 論理演算子
      - 短絡評価 => 評価が決まった段階で評価をやめる
        - AND 演算子（&&）
          - 左辺の値の評価結果が true ならば、右辺の評価結果を返す。
          - 一方で、左辺の値の評価結果が false なら、そのまま左辺の値を返します。
        - OR 演算子（||）
          - 左辺の値の評価結果が true ならば、そのまま左辺の値を返す。
          - 一方で、左辺の値の評価結果が false であるなら、右辺の評価結果を返す。
            - 暗黙的な型交換をおじょなう
              - 左辺が falsy な値の場合には右辺の値を返す
      - falsy な値 => 暗黙的な型変換
        - false
        - undefined
        - null
        - 0
        - 0n
        - NaN
        - ""（空文字列）
  - 被演算子(オペランド)
    - 演算子に演算される対象の事をオペランドと呼ぶ
      - 2 項演算子
        - 2 つのオペランドを取る演算子の事をいう
      - 単項演算子
        - 1 つのオペランドを取る演算子
  - 暗黙的な型変換
    - なぜ JS では等価演算子を使う時に厳密等価演算子の使用を推奨しているのか？
      - JS においては暗黙的な型変換が存在している
        - 厳密等価演算子は暗黙的な型変換を行わずに比較することができる
    - 数値と真偽値の加算
      - 多くの言語ではエラーになる計算
        - JS においては真偽値が演目的な型変換が行われてエラーが起きない
          - エラーが起きないためバグの発見が困難になることがある
    - 暗黙的な型変換とは？
      - ある処理において、その処理過程で行われる明示的ではない型変換のこと
    - ＋演算子
      - JS においては文字列の結合が両方実行できるように多重定義されている
        - 数値＋文字列であれば暗黙的な型変換が重要
          - 2 つのみの単純なオペランドに対する演算であれば結果は予想できる
            - 複数のオペランドを対象に取った時に明示的な型変換をすることがコードの可読性や保守性を担保する
    - 明示的な型変換
      - プリミティブ型へ明示的な型変換する方法
        - 任意の値　＝＞　真偽値
          - 任意の値から真偽値に変換する
            - Boolean()
              - false に変換される値 => falsy な値
                - false
                - undefined
                - null
                - 0
                - 0n
                - NaN
                - ""（空文字列）
        - 数値から文字列
          - String() => String コンストラクタ
        - シンボルから文字列
          - 文字列　＋　シンボル
            - symbol オブジェクトは暗黙的な型変換の対象ではない
        - 文字列から数値
          - Number() => Number コンストラクタ
        - 様々な場所で見る NaN(Not a Number)
          - NaN は Number クラスのオブジェクト
            - NaN は計算過程で出てきた場合にはその計算結果を必ず NaN にする特性がある
              - バグが起きてもどこで NaN に変換されたのかわからないことが多々ある
                - 対策方法
                  - sum 関数側（呼ばれる側）で、Number 型の値以外を受けつけなくする
                    - 呼ばれる側で対応する
                      -
                  - sum 関数を呼び出す側で、Number 型の値のみを渡すようにする
                    - 呼び出す側で対応する
        - 明示的に型変換をしても無理な場合
          - そもそも型の変換が必要なことなのか考える
        - 空文字か判断する
          - 空文字は falsy な値である
            - 0 も空文字になってしまう
              - falsy な値は多くあるため絞り込むことができない
                - 真偽値への値の変換を行う場合には条件を定義する事で変換する
                  - 空文字　＝＞　 length === 0 　のような形
      - まとめ
        - 暗黙的な型変換は意図しない結果となりやすいため避ける
        - 比較には等価演算子（==）ではなく、厳密等価演算子（===）を利用する
        - 演算子による暗黙的な型変換より、明示的な型変換をする関数を利用する
        - 真偽値を得るには、明示的な型変換以外の方法もある
  - void という型
    - 式が値を返さない事を示すために使用するもの
      - 関数が値を返さないようにする
      - 特定の式の評価結果を無視する
    - 使い方
      - 式の計算結果
      ```tsx
      let result = void 0; // undefined が代入される
      console.log(result); // 出力: undefined
      ```
      - 関数での使い方
      ```tsx
      function doNothing() {
        void console.log("This does nothing and returns undefined.");
      }
      doNothing();
      // 出力:
      // This does nothing and returns undefined.
      ```
      - void を使った HTML のイベントハンドラ
      ```tsx
      <a href="javascript:void(0)" onclick="alert('Clicked!');">
        Click me
      </a>
      ```
      - void とクロージャ
      ```tsx
      let counter = (function () {
        let count = 0;
        return function () {
          return void count++;
        };
      })();

      counter(); // count は増加するが、何も返さない
      counter(); // count は再度増加するが、何も返さない
      ```
      - void を使うと常に結果が undefined になる
  - 総合的に知識チェック
    ```jsx
    console.log("表示させたい文字列");
    console.log(数値+数値);
    console.log(数値-数値);
    console.log(数値*数値);
    console.log(数値/数値);
    "8" 文字列
    8 数値

    let name = "mutsukura";
    console.log(name);
    console.log("name");//文字列としてのnameが出力される
    変数はデータに名前をつけた箱
    箱に名前をつけたものが変数名

    const 定数名　= 値
    厳密な定数は上書きできない値
    JavaScriptにおける定数は再代入禁止なもの
    const parson = {name: "ムック",age: 21}
    parson = ランタイムエラーが起きる
    parson.name = "堤竹"
    ↑
    技術面接などで聞かれやすい
    技術において似た概念が多く存在する
    概念同士の違いを理解する事が重要

    条件分岐
    let age = 20;
    if (age >= 18 ) {
     console.log("成人です。");
     }
    ```
  - 繰り返し処理(ループと反復処理)
    - JavaScript において繰り返して同じ処理を行う場合に何度もコードを記載する必要はない
      - ループやイテレーターを使って反復処理を行い実行する事ができる
    - while 文
      - 複数回同内容の処理を行う際に全ての回数分処理を書くのは厳しいため条件を設定して繰り返し処理を行う
        - while (条件式){処理内容}
          - 条件式が true の場合に処理を行う(反復)
      - 処理の流れ
        - 条件式 の評価結果が true なら次のステップへ、false なら終了
        - 実行する文を実行
        - ステップ 1 へ戻る
      - 注意点
        - 無限ループに気をつける
          - 処理内容を定義して実行してから処理内容を適用して更新する事を忘れないようにする事が必要
            - 実行する分の中で条件式に対して効果を与えて最終的には false になるようにする事が重要
    - for 文
      - while 文と同じく繰り返し処理を行うが条件式などの記載方法が簡潔になっている
        - for (変数の定義:条件式:変数の更新){処理内容}
          - 繰り返す範囲を指定した反復処理を記載する事ができる
      - 実行フロー
        - 初期化式 で変数の宣言
        - 条件式 の評価結果が true なら次のステップへ、false なら終了
        - 実行する文 を実行
        - 増分式 で変数を更新
        - ステップ 2 へ戻る
      - 省略した書き方
        - 「number += 1」は「number ++」
        - 「number -= 1」を「number --」
          - と省略して記載できる
      - 数値が 3 倍の場合のコード記載
      ```jsx
      for (let number = 1; number <= 100; number++) {
        // if文を用いて、numberが3の倍数の時に「3の倍数です」、そうでないときは数字を出力してください
        if (number % 3 === 0) {
          console.log("3の倍数です");
        } else {
          console.log(number);
        }
      }
      ```
    - do-while 文
      - while 文とほとんど同じ
        - 実行順序が変わる
      ```Ruby
      do {
          実行する文;
      } while (条件式);
      ```
      - 処理のフロー
        - 実行する文を実行
        - 条件式 の評価結果が true なら次のステップへ、false なら終了
        - ステップ 1 へ戻る
      - while 文との違い
        - まず最初に処理を行う
          - 条件を満たさない場合にも最初の処理は必ず実行される点が違う
    - forEach メソッド　＝＞　非破壊的なメソッド
      - 配列の要素を先頭から順番にコールバック関数に渡して反復処理を行うメソッド
    - filter メソッド　＝＞　非破壊的なメソッド
      - 配列の要素を順番にコールバック関数へ渡し、コールバック関数が true を返した要素だけを集めた新しい配列を返すメソッド
    - reduce メソッド
      - 累積値（アキュムレータ）と配列の要素を順番にコールバック関数へ渡し、1 つの累積値を返す
        - 累積値, 要素, インデックス, 配列を引数として渡す
    - Object.groupBy 静的メソッド
      - 数値からなる配列の要素を奇数と偶数の配列に分ける
        - 任意の値を作成する事ができる
          - 配列からグループ分けしたオブジェクトを完結に作成する事ができる
    - Array-like オブジェクト
      - 配列のように扱う事ができるオブジェクト
        - インデックス
        - 長さ
          - を持っている
        - Array のプロトタイプメソッド
          - 部分的に持っている事がある
  - 配列

    - 複数の値をまとめる方法として配列という方法がある
      - [値 1, 値 2, 値 3]と記載する事で配列にする事ができる
        - 配列は定数に代入する事ができる
          - 配列を代入した定数は習慣上複数形にする
        - console.log(定数名)とする事で代入した定数を出力する事ができる
          - 配列内の値を要素と呼ぶ
    - 配列は Array クラスのオブジェクトである
      - Array オブジェクトの反復処理のためのメソッドが備わっている
    - インデックス番号
      - 配列内の要素は 0 から始まりインデックス番号がついている
        - 配列内の要素を取得したい場合には
          - console.log(変数名[要素のインデックス番号]); とする事で出力する事ができるようになる
            - 二次元配列の場合には => console.log(matrix[0][0]);
              - ２重でインデックス番号を指定する
    - 要素の更新と定数の再定義の違い
      - 配列を定義した定数に新たな定数を代入する事ができない、だが、要素の値を更新する事は可能
    - 配列の配列(二次元配列)
      - 配列の中でさらに配列を定義する事が可能
    - 配列から要素を検索する
      - その要素のインデックスが欲しい場合
        - findIndex メソッド
          - 異なるオブジェクトだけど、値は同じものを条件に 1 番最初に一致する要素を見つけるメソッド
            - 引数に配列の各要素をテストする関数をコールバック関数として渡す
              - テストする処理を自由に書ける
        - findLastIndex
          - 末尾から検索した結果を得られる
        - indexOf
          - 引数と===厳密等価演算子で一致する要素を先頭から検索して該当する要素を返す、該当する要素がない場合には-1 を返す
        - lastIndexOf
          - 引数と===厳密等価演算子で一致する要素を末尾から検索して該当する要素を返す、該当する要素がない場合には-1 を返す
      - その要素自体が欲しい場合
        - 特定の要素のインデックスを取得してそのインデックスを使って配列にアクセスする事で要素自体を取得する事ができる
          - しかし、インデックスを取得したい場合と要素を取得したい場合が明確でなくなってしまう
        - find メソッド
          - 要素自体が欲しい場合には find メソッドを使う
            - 配列の各要素をテストする関数をコールバック関数として渡す事ができる
              - 返り値は要素そのもの、値が存在しない場合には undefined が帰ってくる
        - findLast メソッド
          - find 関数と処理は同じで末尾から検索した結果を得る事ができる
      - 特定の要素自体を取得する事に加えて指定範囲の要素を取得する方法
        - slice メソッド
          - 第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい配列を作成する
            - 第 2 引数は省略可能で、省略すると配列の末尾の要素まで含んだ新しい配列を返す
      - その要素が含まれているかという真偽値が欲しい場合
        - 指定した要素が含まれているかだけを知りたい場合
          - includes メソッド
            - 異なるオブジェクトだが値が同じものを見つけたい場合には利用できない
          - some メソッド
            - テストするコールバック関数にマッチする要素があるなら true を返して存在しない場合には false を返す
    - 可変長である配列の追加と削除
      - 追加
        - 作成後の配列に対して要素を末尾に追加する Array の Push が利用できる
        - 作成後の配列に対して要素を先頭に追加するには unshift を利用する
      - 削除
        - 作成後の配列に対して末尾の要素を削除するメソッド
          - pop
            - const poppedItem = array.pop();
        - 作成後の配列に対して先頭の要素を削除するメソッド
          - shift
            - const shiftedItem = array.shift();
        - 指定したインデックスの要素を削除するメソッド
          - array.splice(インデックス, 削除する要素数);
            - 削除と同時に要素の追加もできる
              - array.splice(インデックス, 削除する要素数, ...追加する要素);
        - 配列の要素を length プロパティへの代入を使って削除する方法
          - 配列の length プロパティで値を代入を行う事で指定したインデックス番号移行の要素を削除する事ができる
            - array.length = 0; // 配列を空にする
    - 配列同士の結合
      - concat メソッドを使うと指定した配列と配列を結合して新しい配列を作成できる
        - 配列を作成する => 作成した配列に concat メソッドの引数に新しい配列を渡して配列の結合を行う
      - concat メソッドは任意の値を要素として結合する事も可能
        - 配列の作成 => 任意の値を要素して結合する
    - 配列の展開
      - ... => スプレッド構文を使う事で既存の配列を展開する事ができる
        - ["X", "Y", "Z", ...array];
          - 基本的には concat メソッドを使った時と同等の処理になる
            - スプレッド構文は配列リテラルの中に展開する事ができるので任意の位置に配列を展開して要素を追加できる
          - 新しい配列を作成して返すメソッド
            - 同じ処理結果になる処理(それ以上フラット化できない)を実行しても新しい同じ要素を持つ配列を返す
    - 配列のフラット化
      - flat メソッド
        - 多次元配列をフラットな配列に変換できる
          - 引数を指定しない場合 or 1 を指定する場合には 1 段階のフラット化
        - 配列を全てフラット化する場合には無限を意味すう rInfinity を値として渡す
    - 配列名.length
      - 配列の数、数値を代入するもの
        - 配列に対する繰り返し処理などの際に多く活用する事が多い
          - 配列の最後の要素にアクセスしたい場合などには
            - array.length - 1 をインデックスとして利用する
    - 存在しないインデックスへのアクセス
      - 存在しないインデックスへアクセスした場合には例外がかえされるのではなく、undefined を返される
        - Array もオブジェクトの一種である
          - 存在しないプロパティにアクセスした場合でも undefined が返される
    - 疎な配列
      - 配列は常に length の数だけ要素を持っているわけではない
        - 値を省略する事で未定義の要素を含める事ができる
          - 配列の中に隙間があるものを疎な配列と呼ぶ
          - 配列全ての要素に値がある配列を密な配列と呼ぶ
    - Array.prototype.at
      - 配列の末尾の要素へのアクセス
        - 引数に相対的な配列の要素を指定する事で要素にアクセスする事ができる
          - (0)や(1)などの 0 以上の要素は配列内のインデックス番号に乗っ取り要素へアクセスする
          - (-1)などのマイナスの要素を指定して場合は末尾から数えた位置の要素にアクセスする事ができる
    - オブジェクトが配列かどうかを判定する
      - Array.isArray メソッド
        - 引数が配列の場合,true を返して配列ではない場合,false を返す
          - typeof 演算子は使う事ができない
            - Array もオブジェクトの一種になるため
    - TypedArray
      - 固定長かつ型付きの配列を扱うオブジェクト
        - バイナリーデータのバッファを示す際などに使用する
          - WebGL やバイナリを扱う
            - Array.isArray の評価値も false になる
              - JS における配列　＝＞　 Array を示す
    - forEach メソッド

      - for 文と同じような反復処理を行うメソッド
        - for 文のように i といった一時的な条件の定義をする必要がない事でシンプルに記載できる利点がある

      ```Ruby
      const array = [1, 2, 3];
      array.forEach(currentValue => {
          // 配列の要素ごとに呼び出される処理
          // currentValueには配列の1~3の値が順番に渡される
      });
      ```

      - 無名関数を引数として渡す
        - 渡される関数　＝＞　コールバック関数
        - コールバック関数　＝＞　高階関数
      - 例えば、sum 関数

        - ```Ruby
            function sum(numbers) {
                let total = 0;
                numbers.forEach(num => {
                    total += num;
                });
                return total;
            }

            sum([1, 2, 3, 4, 5]); // => 15
          ```

        ```

        ```

    - break
      - 繰り返し処理やループを抜け出し次のループに制御を移す
    - continue 文
      - while、do-while、for の中で使う事ができる
        - 現在の反復処理を終了して次の反復処理を行う
    - filter 関数
      - 条件に応じた特定の処理のみを集めて配列を作成するメソッド
    - for...in
      - オブジェクトのプロパティに対して、反復処理を行う
      ```Ruby
      for (プロパティ in オブジェクト) {
          実行する文;
      }
      ```
      - 一つのオブジェクトに対して 1 つのブロックを作成して反復処理を行う
      ```Ruby
      const obj = {
          "a": 1,
          "b": 2,
          "c": 3
      };
      // 注記: ループのたびに毎回新しいブロックに変数keyが定義されるため、再定義エラーが発生しない
      for (const key in obj) {
          const value = obj[key];
          console.log(`key:${key}, value:${value}`);
      }
      // "key:a, value:1"
      // "key:b, value:2"
      // "key:c, value:3"
      ```
      - for...in 文の注意点
        - JavaScript におけるオブジェクトは様々なプロパティを継承している可能性があり、親オブジェクトまで列挙可能なオブジェクトをあげてしまう可能性があり
          - その場合、意図しない結果になってしまう可能性がある
      - 安全に列挙する方法
        - Object.keys メソッド
          - 引数のオブジェクト自身が持つプロオアティを出力する
        - Object.values メソッド
          -
        - Object.entries メソッド
    - 破壊的なメソッドと非破壊的なメソッド
      - 破壊的なメソッド(Mutable Method)
        - 配列オブジェクトそのものを変更し変更した配列や変更箇所を返すメソッド
          - 例:
            - push メソッド
        - 破壊的なメソッドには副作用を与えてしまうため副作用がある事を意識して利用する必要がある
      - 非破壊的なメソッド(Immutable Method)
        - 配列オブジェクトのコピーを作成してから変更して、コピーした配列を返す
          - 例:
            - concat メソッド
      - 今まで、破壊的なメソッドをと非破壊的なメソッドが混合しており、名前からも区別する事が難しく、副作用を避けるためにコピーを作成してから破壊的なメソッドを使うというパターンが使われてきた
        - しかし、ES2023 で to から始まる非破壊的なメソッドだが、内容は破壊的なメソッドと同様の処理が追加された

  - オブジェクト　＝＞　 Object というビルトインオブジェクト
    - 複数の値を管理する方法
      - オブジェクト
        - プロパティの集合
          - プロパティ　＝＞　名前（キー）と値（バリュー）が対になったもの
            - キー
              - 文字列 or Symbol が利用できる
                - 値には任意のデータを指定する事ができる
                  - 1 つのオブジェクトで複数のプロパティを持てる
      - 値に対してプロパティ名をつける事で管理する
        - オブジェクトは{}で囲む　＝＞　オブジェクトリテラル
        - プロパティ名と値の間はコロン（ : ）で繋ぐ
        - プロパティ間はコンマ（,）で区切る
          - キーの初期値を定義する
            - クォート（"や'）を省略できる
              - 変数名として使う事ができないハイフンなどが出てくる場合にはクォート（"や'）で囲む必要あり
      - オブジェクトも定数に代入する事が可能
    - オブジェクトの値を取り出す
      - オブジェクト.プロパティ名とする事で取り出せる
    - オブジェクトの値を更新する
      - オブジェクト.プロパティ名 = 新しい値
    - オブジェクトを要素に持つ配列
      - 配列の要素がオブジェクトになっている場合
        - オブジェクトに対してインデックス番号が振られている
          - 配列内のオブジェクトの値を取り出す
            - 配列[インデックス番号].プロパティ名
    - オブジェクトの値に変数名を指定すると変数の参照先をオブジェクトが参照する事になる
      - 指定する変数とプロパティ名が一緒の場合には省略して記載する事ができる
    - オブジェクト内のプロパティにオブジェクトを用いる事ができる
      ```jsx
      const names = {
          name:{
              firstName:"kouki"
              homename:"mutskura"
              }
          };

      ```
      - 呼び出し方法
        - .記法
          - 「オブジェクト名.プロパティ.プロパティ」
        - []ブランケット記法
          - console.log(obj["key"]);
            - 暗黙的に文字列に変換されてプロパティを探す事ができる
    - オブジェクト内のプロパティの値には配列を用いる事も可能
      ```jsx
      const nameList = {
        name: ["kouki", "toyoda", "tutumitake"],
      };
      ```
    - オブジェクトの例 - 配列・関数　＝＞　オブジェクトの一種
    - Object というビルトインオブジェクト
      - ECMAScript の仕様で定義されているもの
        - あらゆる JS 環境で利用する事ができる
          - {}は Object のインスタンスオブジェクト
            - {} => new Objet()
              - 同義である
                - 同義ではあるが、明きらかに簡潔で初期値の設定も可能なのでリテラルを基本的には使用する
    - オブジェクトと分割代入
      - .記法で値を呼び出そうとすると冗長なコードになってしまう事がある
        - プロパティを定数として定義した上で使用する事がある
      - 分割代入
        - 左辺にオブジェクトリテラルのような構文で変数名を定義する
          - 右辺のオブジェクトから対応するプロパティ名
          - 左辺で定義した変数に代入される
        ```JavaScript
        const languages = {
            ja: "日本語",
            en: "英語"
        };
        const { ja, en } = languages;
        console.log(ja); // => "日本語"
        console.log(en); // => "英語"
        ```
      - ミュータブルなオブジェクト
        - プロパティの追加
          - すでに作成したオブジェクトに対して後からプロパティを追加する事が可能
            - ドット記法　＝＞　変数の識別子として利用可能なプロパティ名のみ
            - ブラケット記法 ＝＞　 object[式]の式の評価結果を文字列にしたものをプロパティ名として利用できる
              - 変数
              - 変数の識別子として扱えない文字列
              - Symbol
            - ブランケット記法を用いたプロパティ定義はオブジェクトリテラルの中でも使う事ができる
              - Computed property names
                - Computed proputed names を使った変数の評価結果をプロパティ名に変換する方法
              ```JavaScript
              const key = "key-string";
              // Computed Propertyで`key`の評価結果 "key-string" をプロパティ名に利用
              const obj = {
                  [key]: "value"
              };
              console.log(obj[key]); // => "value"
              ```
            - プロパティの追加はエラーの原因になる可能性があるため推奨されない
              - 最初の初期値のみを使う
            - プロパティの削除
              - deleta メソッドを使う
            ```JavaScript
            const obj = {
                key1: "value1",
                key2: "value2"
            };
            // key1プロパティを削除
            delete obj.key1;
            // key1プロパティが削除されている
            console.log(obj); // => { "key2": "value2" }
            ```
    - プロパティの存在を確認する
      - in 演算子
        - 指定したオブジェクトにプロパティが存在するか判定する
          - そのあとに真偽値を返す
      - Object.hasOwn(静的メソッド)
        - 指定したオブジェクトにプロパティが存在するか判定する
          - そのあとに真偽値を返す
    - プロパティの値を取得したい場合
      - if 文で undefind と比較する方法で問題ない
    - Optional chaining 演算子
      - Optional chaining 演算子（?.）は左辺のオペランドが nullish（null または undefined）の場合、それ以上評価せずに undefined を返します。
        - 一方で、プロパティが存在する場合は、そのプロパティの評価結果を返します。
          - 存在しないプロパティへアクセスする場合でも undefind を返す
            - Optional chaining とブランケット記法を組み合わせる方法もある
    - オブジェクトのプロパティ名は文字列化される
      - オブジェクトのプロパティへアクセス
        - 指定したプロパティ名は文字列化される
          - Symbol のみはプロパティとして使う事ができる
      - オブジェクトの静的メソッド
        - Object.keys メソッド: オブジェクトのプロパティ名の配列にして返す
        - Object.values メソッド[ES2017]: オブジェクトの値の配列にして返す
        - Object.entries メソッド[ES2017]: オブジェクトのプロパティ名と値の配列の配列を返す
    - オブジェクトのマージと複製
      - Object.assign メソッド
        - オブジェクトを別のオブジェクトへ代入する事ができる
          - オブジェクトの複製
            - 空のオブジェクトをターゲットにする事でマージしたオブジェクトを作成できる
            ```JavaScript
            const objectA = { a: "a" };
            const objectB = { b: "b" };
            const merged = Object.assign({}, objectA, objectB);
            console.log(merged); // => { a: "a", b: "b" }
            ```
          - オブジェクトのマージ
    - オブジェクトについてまとめ
      - Object というビルトインオブジェクトがある
      - {}（オブジェクトリテラル）でのオブジェクトの作成や更新方法
      - プロパティの存在を確認するには in 演算子か Object.hasOwn 静的メソッドを使う
      - Optional chaining 演算子（?.）はネストしたプロパティの存在確認とアクセスを同時に行う記法
      - オブジェクトのインスタンスメソッドと静的メソッド
  - undefined
    - 存在しないプロパティなどを指定すると特別な値の undefined が出力される
      - 未定義のプロパティという意味
        - JS においては存在しないプロパティに対するアクセスや、例外を発生するような処理を行った場合にエラーにならずに undefined という値を返すため間違いに気づけなくなる事が多々ある
  - 関数

    - 関数とは
      - いくつかの処理をまとめたもの
        - 関数を構成すつ 4 つの要素
          - 関数名 - 利用できる名前は変数名と同じ
          - 仮引数 - 関数の呼び出し時に渡された値が入る変数。複数ある場合は,（カンマ）で区切る
          - 関数の中身 - {と}で囲んだ関数の処理を書く場所
          - 関数の返り値 - 関数を呼び出したときに、呼び出し元へ返される値
    - 関数の定義
      - const 定数名 = function(){}
        - {}の中にまとめたい処理を書く事で関数を用意できる
          - 関数を用意する事を関数を定義するという
    - 関数の呼び出し
      - 関数を定義した際に使用した定数名を使用して関数を呼び出す
        - 定数名();
    - アロー関数
      - 通常、変数の定義は function()で行うが ES6 から() => と記載する事でも関数の定義ができる
    - 引数

      - 引数とは
        - 関数を呼び出した際に渡すデータ
          - 括弧の中に引数名を書く事で引数を受け取る事ができる
            - (引数名) =>
          - 関数を呼び出す際に引数を渡す事で関数に値が渡される
            - 定数名(引数として渡す値);
              - 引数として渡した値が引数名に代入される
      - 複数の引数を受け取る関数

        - 受け取る引数をコンマ(,)で区切って並べることで、複数の引数を指定することができる。
          - 左から順に第 1 引数、第 2 引数、第 3 引数のようになっていく
            - 関数側で設定した仮引数よりも少ない数の引数が渡された場合には undefined が代入される
            - 関数側で設定した仮引数よりも多い場合、溢れた引数は無視される
        - [ES2015] デフォルト引数

          - 仮引数に対応する引数が渡されていない場合のデフォルトで代入される値を指定する事ができる

            - ```JavaScript
                function echo(x = "デフォルト値") {
                    return x;
                }

                console.log(echo(1)); // => 1
                console.log(echo()); // => "デフォルト値"
              ```

            ```

            ```

        - 可変長引数
          - 任意の個数の引数を受け取る事ができる
            - Rest parameters
              - 仮引数名の前に...をつけた仮引数 => 残余引数
                - 関数に渡された値が配列として代入される
                  ```JavaScript
                  function fn(...args) {
                      // argsは、渡された引数が入った配列
                      console.log(args); // => ["a", "b", "c"]
                  }
                  fn("a", "b", "c");
                  ```
                - 通常の仮引数と組み合わせる事ができる
                  - 条件：
                    - 必ず、末尾に Rest parameters が来るようにする
              - 値をまとめて配列にして代入する仕組みが Rest parameters
                - 配列を展開して代入する仕組みも存在する
                  - Spread 構文
                    - 配列の前に...をつけた構文
                      - 配列の値を展開したものが引数として渡される
            - 関数の中でのみ参照できる特殊な変数 arguments
              - 渡された値が全て入った Array-Like なオブジェクト
                - 値をインデックス要素でアクセスする事ができる
                  - しかし、Array オブジェクトのメソッドなどを使用する事はできない
          - Rest Parameters が使用できる場面で arguments 変数を使う理由はない
            - Arrow Function では利用できない（Arrow Function については後述）
            - Array-like オブジェクトであるため、Array のメソッドを利用できない
            - 関数が可変長引数を受けつけるのかを仮引数だけを見て判断できない
        - 分割代入（Destructuring assignment）
          - オブジェクトや配列からプロパティを取り出し、変数として定義し直す構文
            - 関数に渡す引数を右辺と考えるとほぼ同じ構文である
              - オブジェクトに対する分割代入
                ````JavaScript
                    const user = {
                        id: 42
                    };
                    // オブジェクトの分割代入
                    const { id } = user;
                    console.log(id); // => 42
                    // 関数の引数の分割代入
                    function printUserId({ id }) {
                        console.log(id); // => 42
                    }
                    printUserId(user);
                    ```
                ````
              - 配列に対する分割代入
                ````JavaScript
                   function print([first, second]) {
                       console.log(first); // => 1
                       console.log(second); // => 2
                   }
                   const array = [1, 2];
                   print(array);
                   ```
                ````

    - 戻り値
      - 関数での処理結果を戻り値として受け取る
        - 関数内で return と記載する
          - 呼び出した関数に戻り値がある場合には呼び出し元が戻りにそのまま代入される
        - return は実行されると関数の処理を終了させる性質がある
          - 処理を何もしない場合には return のみを記載する事で undifind を返す事ができる
        - return の記載を省略する事も可能
      - 戻り値の活用
        - 真偽値の取得
          - if 文の条件式を return すると条件式の結果として真偽値(true or false)を得る事ができる
    - スコープ
      - 定数や変数の使用できる範囲の事
        - 関数の外側で定義した定数、変数はプログラムのどこからでも使う事ができる
        - 関数の{}で定義した定数や変数は定義した関数内のみで使用できる
          - while 文などの中括弧がある構文でもスコープが作成される
      - 同じ名前の定数、変数がある場合にもスコープの範囲に応じて処理が変わる
    - 関数はオブジェクト
      - JS において関数は関数オブジェクトと呼ばれる
        - 関数を値として扱う事ができる
          - ファーストクラスファンクション
            - 関数式
              - function キーワードを使った方法
                - 関数を値として変数へ代入している
                  - 名前を持たない関数(無名関数)を定義する事ができる
              - Arrow Function を使った方法
                - 矢印のような=>（イコールと大なり記号）を使い、無名関数を定義する構文
                  - 関数の引数が 1 つの時には()を省略する事ができる
                  - 関数の処理が 1 つの場合にはブロックと return 文を省略する事ができる
      - JS において関数はオブジェクトであるためプロパティを介して値を代入する事ができる
        - しかし、推奨されていない
          - 関数外からプロパティを指定する事で変更する事が容易になってしまっている
            - 関数内部のみで参照したい場合にはクロージャーを使う事が良い
    - 同じ関数名の宣言は上書きされる
      - 関数宣言で定義した関数は関数の名前のみで区別される
        - 同じ名前での定義は後ろで定義した関数が定義される
          - 予期していない挙動になる事があるため基本的には同じ名前での定義は行わない
    - コールバック関数
      - ファーストクラスとしての関数を関数に引数として渡す事
        - 高階関数と呼ぶ
    - メソッドの短縮記載
      - メソッドとしてプロパティを定義するための短縮した書き方
        - オブジェクトリテラルの中で メソッド名(){ /_メソッドの処理_/ }と記載する
          ```JavaScript
          const obj = {
              method() {
                  return "this is method";
              }
          };
          console.log(obj.method()); // => "this is method"
          ```

  - クラス構文
    - クラスとは
      - 効率よくオブジェクトを作成するための設計図
        - 複数のオブジェクトを作成する際の型
      - クラスの用意
        - class クラス名
          - クラス名は基本、大文字で開始する
      - インスタンスの作成
        - クラスを元にオブジェクトを作成する
          - new クラス名()
            - クラスを元に作成したオブジェクトをインスタンスと呼ぶ
              - Animal クラスのインスタンスを Animal インスタンスと呼ぶ
      - コンストラクター
        - 設計図の中身
          - インスタンスの作成時や設定内容を追加するための機能
            - インスタンスが作成される毎に実行される
        - クラスの{}内に記載する
          - constructor() { }
        - 作成されたインスタンスにプロパティと値を追加する方法
          - this.プロパティ名 = 値
            - クラスの外でインスタンス.プロパティ名とする事でクラスの外でも使用する事が可能になる
        - 引数を受け取る
          - コンストラクタは引数を受け取る事ができる
            - インスタンス毎に値を変えたい場合などに対応できるように
              - 引数を()内で受け取って、{}内で this.引数名などとして引数を受け取る
                - インスタンスを作成する際に値を渡してコンストラクタが受け取れるようにする
      - メソッド
        - 情報（名前や年齢）を追加したのがプロパティ
        - メソッドはインスタンスの動作、振る舞いを設定する
          - クラス内でメソッド名() { }のように記載する
        - メソッドの呼び出し方
          - インスタンス.メソッド名()
        - インスタンス内でメソッドを使用する場合
          - this を使用する
            - **this.プロパティ名**
        - メソッド内でメソッドを使う
          - this.メソッド名()
  - クラスの継承
    - 継承とは？
      - すでに作成したクラスを元に新しいクラスを作成する事
        - 「Animal クラス」を継承して「Dog クラス」を作成する場合
          - 「class Dog extends Animal」と書く
        - 親クラス、子クラス
          - 親クラス
            - 継承される元のクラス
          - 子クラス
            - 元のクラスを継承するクラス
      - 親クラスのメソッドを使う
        - 親クラスで定義されたメソッドは子クラス内でも使う事が可能
          - インスタンス.メソッド名();
      - 子クラス内で独自のメソッドを作成する
        - 子クラス内では独自にメソッドを作成する事が可能
          - 通常と同じようにメソッド名(){}と記載する
      - メソッドの戻り値
        - 関数と同じでメソッドは戻り値を受け取る事ができる
    - オーバーライド
      - 継承先の子クラスで継承元の親クラスと同名のメソッドを作成した場合はどうなるのか？
        - 子クラスで定義したメソッドに内容が上書きされる
  - ファイルの分割
    - コードの量が多くなってくると一つのファイルで管理する事が困難になるためファイルを区切りで分割する
      - ファイルを分割すると当たり前だが分割した部分のコードがなくなってしまい必要な処理がなくなってしまうためエラーになってしまう。
    - エクスポート
      - クラスの定義の後に export default クラス名とする事でクラスをエクスポートして他のファイルに渡す事ができる
    - インポート
      - 他のファイルで定義されているクラスを使用するにはインポートをする必要がある import クラス名 from "./ファイル名”
  - 値のエクスポート
    - クラスのみではなく、メソッドや定数など値は分割する事が可能になっている
      - エクスポート
        - export default 分割したい値
      - インポート
        - import 分割したい値 from "./ファイル名”
    - デフォルトエクスポート
      - 各ファイルにつき 1 回までしか使う事ができない
        - インポートの際に分割したい値が間違えていてもデフォルトとしてエクスポートされるようになっている
  - 名前付きエクスポート
    - export default は 1 回しか使用できない。
      - その他の方法として名前付きエクスポートがある
    - 名前付きエクスポート
      - export {値の名前}
        - カンマを使う事で複数の値を指定してエクスポートする事ができる
    - 名前付きエクスポートしたものをインポートする
      - import { 値の名前 } from "./ファイル名”
        - インポートの際も同様でカンマで区切る事で複数の値をインポートできる
  - 相対パス
    - import する際のファイルを指定方法
      - ファイルを指定する際には import をするファイルからみた export の位置関係を示している
    - 同じディレクトリ内にいる場合
      - ./ファイル名;
        - ./で同じディレクトリという事を示す
    - 異なるディレクトにいる場合
      - 同じ親ディレクトリ内のディレクトリが違うファイルを指定する方法
        - ./ディレクトリ名/ファイル名;
          - ./ディレクトリ名/で同じディレクトリ内のディレクトリ名を指定する
          - その後、ファイル名を指定する
    - 1 つ上の階層に戻る必要がある場合
      - ../ディレクトリ名/ファイル名;
        - 親ディレクトリ内の違うディレクトリに入っているファイルを指定したい場合
          - ../でディレクトリの階層を戻る
          - ディレクトリ名の指定をする
          - ファイル名の指定
  - パッケージ
    - 他の人が作成した機能を使う事ができる
      - JavaScript の機能を使う事でプログラムに組み込む事ができる
    - import 定数名 from “パッケージ名”;
      - 例：chalk “文字列に対して色をつける事ができパッケージ”
        ```jsx
        import chalk from "chalk";
        console.log(chalk.yellow(colorisyellow));
        ```
      - 例：readline-sync 　”コンソールへの入力、入力された値をプログラムで使用する”
        - readlineSync.question(質問文)
          - 入力された内容を定数に代入すると入力内容がそのまま代入される
        - 整数の入力を要求する時
          - readlineSync.questionInt(質問文) 　とする
      ```jsx
      import readlineSync from readlinesync
      const name = readlineSync.question("名前を入力してください”)
      const age =  readlineSync.questionInt("年齢を入力してください”)
      new human (name,age)
      ```
  - split メソッド
    - 第一引数に指定 s た区切り文字で文字列をもっと分解した配列を返す
  - join メソッド
    - 第一引数には区切り文字を指定してその区切り文字で結合した文字列を返す
  - push メソッド
    - 配列の最後に値を追加する事ができるメソッド
      - 配列名.push(配列の最後に追加したい値）
  - forEach メソッド
    - 配列内の全ての要素に対して繰り返して同じ処理を行う事
      - アロー関数が入っている
        - 引数に対して処理を行う
      - コールバック関数
        - 引数に入っている関数はコールバック関数と呼ばれる
      - 良いコードを書く
        - 関数が 1 列に長くなってしまうと悪い関数になってしまう
          - {で改行すると良いコードになる
      - 配列名.forEach(アロー関数)
        - (character) => {console.log(character);}
      ```jsx
      characters.forEach((character) => {
        console.log(character);
      });
      ```
    - メソッドの中に関数が入る形の記載が多くなってくる
  - find メソッド
    - 配列から条件式に合う 1 つ目の要素を配列の中から取り出すメソッド
      - 要素を順番に検証していき 1 番最初に対応するものがあったらその情報を元に操作を行う。
        - コールバック関数の中身
          - { return 条件 }　と記載する
      - 要素がオブジェクトの場合にもプロパティを指定する事でオブジェクトそのものを呼び出す事ができる
  - filter メソッド
    - 配列から条件に合う要素を全て取り出して配列にするメソッド
      - find メソッドと同様に要素がオブジェクトの場合においてもプロパティを指定する事でオブジェクトそのものを呼び出す事ができる
  - map メソッド
    - 配列内の要素全てに対して共通する処理を行い、処理を行った要素で新しい配列を作るメソッド
      - コールバック関数の中身
        - { return 値 }
      - 配列のオブジェクト要素に対しても使うこともできる
        - return name.firstname + name.lastName
  - length メソッド
    - 文字列の要素数を返す
      - 文字列 Code Unit の個数を返す
  - slice：破壊的なメソッド
    - 第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい文字列を返すメソッド
      - 第二引数を省略する事ができ、省略した場合には末尾まで含んだ新しい文字列を返す
  - substring => String クラス：破壊的なメソッド
    - 第一引数に開始位置、第二引数に終了位置を指定し、その範囲を取り出して新しい文字列を返す
      - 第二引数は省略可能で省略した場合は文字列の末尾が終了位置になる
        - -1 などの 0 以下の数字を指定すると 0 として扱われる
        - 第二引数の値が第一引数より大きい場合、入れ替わり評価される
    - マイナスの位置が入れ替わる、引数が交換されるなどの挙動があるメソッドの引数には渡す形式を限定して渡す事で予期しない結果を防ぐ事が出来る
      - 機能的には差はほとんどないため好みで使い分ける
  - コールバック関数に関して
    - Web アプリ開発においてコールバック関数は頻出であり理解する事が開発において必要
      - 関数の引数に他の関数を渡している関数をコールバック関数と呼ぶ
  - JavaScript の関数において渡せるもの
    - 文字列
    - 数値
    - 真偽値
    - 関数　 → コールバック関数と呼ぶ
  - コールバック関数の流れ
    - 関数は、関数名の後ろに()をつけると呼び出される。
      - ()をつけなければ関数そのものを指す。
    ```jsx
    const printWanko = () => {
      console.log("にんじゃわんこ");
    };

    const call = (callback) => {
      console.log("コールバック関数を呼び出します");
      callback();
    };

    call(printWanko);
    ```
  - 関数の流れ
    1. 関数 printWanko を定義する
       - 実行されると文字列としてのにんじゃわんこを出力する
    2. 関数 call**を定義する**
       - 実行されると引数として関数 callback を渡す。
         - 文字列としてのコールバック関数を呼び出しますを出力する
         - callback に引数として渡された関数 printWanko を実行する
    3. 関数 call を呼び出し、引数として関数 printWanko を渡す
  - コールバック関数は事前に定義した関数だけなく、直接定義する事も可能
    ```jsx
    () => {
      console.log("ひつじ仙人");
    };
    ```
    ```jsx
    // 事前に関数を定義して渡す
    ↓
    const printWanko = () => {
      console.log("にんじゃわんこ");
    };

    const call = (callback) => {
      console.log("コールバック関数を呼び出します。");
      callback();
    };

    call(printWanko);

    // 直接アロー関数を定義して渡す
    ↓
    // 引数で関数を定義して渡してください
    call(() => {
      console.log("ひつじ仙人");
    });
    ```
    - 渡す引数に応じて関数で表示される内容を変える事ができる
    - 複数の引数を渡す事もできる
      - 渡す引数の数、順番は間違えないように注意が必要
    ```jsx
    const call = (callback) => {
      callback("にんじゃわんこ", 14);
    };

    call((name, age) => {
      console.log(`${name}は${age}歳です。`);
    });
    ```
  - プロトタイプオブジェクト
    - オブジェクトは k 空のオブジェクトを定義した後に toString メソッドなどを使用する事ができる
      - しかし、オブジェクトには文字列などが入っていない
        - この toString メソッドなどはどこに実装されているのか？
          - JS のオブジェクトにおいては自動的にオブジェクトに組み込まれたメソッドが多くある　＝＞　ビルトインメソッド
    - Object は全ての元
      - 継承関係　：　 Object ＝＞　 Array,String,Function
        - Object.prototype プロパティに定義された prototype オブジェクトを継承している
          - prototype オブジェクト => ベースオブジェクト
            - これらのオブジェクトはインスタンスの生成時に自動的に継承される
              - インスタンスから呼び出す事が可能であり、空のリテラルでも呼び出す事が可能な理由はこれによるため
          - プロトタイプチェーン
            - インスタンスからプロトタイプメソッドを呼び出す事ができる
    - 短縮記法
      - Object.prototype.toString を Object#toString と記載する
        - #が JS の構文に使用されない事から prototype の短縮表現として使われる
    - オーバーライド
      - 同名のメソッドを定義した場合には新しく定義したメソッドが実行されう
        - 最新のメソッドに上書きされる
    - Object.hasOwn 静的メソッドと in 演算子との違い
      - Object.hasOwn 静的メソッド
        - オブジェクト自身が指定したメソッドを持っているか判定する
          - protpype メソッドを継承してない場合でも使う事が可能なメソッド
      - in 演算子
        - 指定したメソッドをオブジェクト自身が持っているか探索し、持っていない場合にはさらに prototype オブジェクトまで探索する
          - オブジェクト自身が持っているメソッドなのか、prototype オブジェクトが持っているメソッドなのかを判別しない
    - Object.create メソッド
      - 第一引数に指定した prototype オブジェクトを継承した新しいオブジェクトを作成できる
        - const obj = Object.create(Object.prototype);と const obj = {}
    - Array も Object を継承している
      - Array のインスタンス → Array.prototype → Object.prototype
        - Array オブジェクトはメソッドを継承し独自のメソッドとして利用する事ができるようになる
          - Array.prototype.toString が独自に呼び出される
    - Object.prototype を継承しないオブジェクト - Object.create(null)とする事で Object.prototype を継承しないオブジェクト(プロパティ、メソッドを持たない本当に空のオブジェクトを作成できる)
      **まとめ**
    - オブジェクトの生成時に自動生成される
      - 例：
        - toString
    - オブジェクトはほとんどが Object.prototype を継承しているため toString を呼び出せる
      - プロトタイプメソッド
        - オブジェクトのインスタンスは Object.prototype オブジェクトに定義されたメソッドやプロパティを継承する
  - ラッパーオブジェクト
    - JS にはプリミティブ型とオブジェクトがある
      - プリミティブ型には数値や文字列、真偽値、文字列、シンボルなどがある
        - プリミティブ型であってもオブジェクトのメソッドなどを呼び出して使用する事ができる
          - プリミティブの記載方法はリテラル記法、new を使ってインスタンスを生成する方法の 2 通りがある
            - リテラル記法を使った場合にも必要な場合には自動的に new する時と同様にラッパーオブジェクトに変換してくれる
              - このようにリテラル記法を実施した場合にもメソッドなどを使う事ができるようになっている
      - JavaScript は全てがオブジェクトであるわけではない
        - オブジェクトのように扱う事が可能であるという事
  - メソッドチェーン
    - 返り値に対してメソッド呼び出しをするパターンのことを言う
      - concat メソッドの返り値に対してさらに concat メソッドを実行するなど
        - メソッドチェーンを使用することで簡潔に記載することなどができる
          - 複数の処理を 1 つの処理かのようにまとめて記載する事ができるようになる
            - 長すぎるメソッドチェーンは処理を読みにくくする事になるため注意
  - 文字列による検索
    - 指定した文字列で検索するメソッドが用意されている
      - String オブジェクトに用意されている
    - indexOf と lastIndexOf
      - 指定した文字列で検索すう r
        - 最初にヒットしたインデックスを返す
          - Array の indexOf とメソッドと同様に===の厳密等価演算子で評価する
            - 結果がない場合には-1 を返す
    - 文字列.indexOf("検索文字列")
      - 先頭から検索し、指定された文字列が最初に現れたインデックスを返す
    - 文字列.lastIndexOf("検索文字列")
      - 末尾から検索し、指定された文字列が最初に現れたインデックスを返す
    - 指定した文字列が含まれているか？真偽値を返すメソッド(ES2015)
      - String.prototype.startsWith(検索文字列)[ES2015]
        - 検索文字列が先頭にあるかの真偽値を返す
      - String.prototype.endsWith(検索文字列)[ES2015]
        - 検索文字列が末尾にあるかの真偽値を返す
      - String.prototype.includes(検索文字列)[ES2015]
        - 検索文字列を含むかの真偽値を返す
  - スコープ
    - 変数や関数などの参照をできる範囲を定義しているもの
      - 関数スコープ
        - 仮引数
          - JS の関数には仮引数を定義する事ができるが、仮引数はその関数内のみで参照でき、関数外から参照しようとするとリファレンスエラーが起きる
        - 関数内の変数
          - 関数内で定義した変数は関数内のみで参照できる、関数外からの参照はエラーが起きてしまう
      - ブロックスコープ
        - if 文や while 文などにおいて{}で囲まれたブロックを定義する事がある。ブロックにもスコープの概念があり、外からの参照ができなくなる。
          - if 文や while 文においてループの度に新しいブロックを形成してその上で処理を行う仕組みになっている
            - 同名の変数定義などを行ってもエラーが起きないのはこのループがブロックでありスコープが分かれているからである
      - スコープチェーン
        - スコープは階層的な構造になっている
          - 関数やブロックはネスト（入れ子）する事ができる
            - ネストされた構造においてスコープを内側と外側に分けて判別する
              - 内側スコープ　＝＞　 inner ブロックスコープ
              - 外側スコープ　＝＞　 outer ブロックスコープ
                - 現在いるスコープを内側と定義して、変数を呼び出す際には内側スコープを探して、その後に外側スコープへ移動するという流れで変数を探す
                  - 同名の変数が内側と外側で定義されている場合には内側の変数が優先される事になる
      - グローバルスコープ(変数の隠蔽)
        - コードをプログラム直下においた場合に対応するスコープは 1 番外側に存在するスコープ＝＞グローバルスコープ
          - ビルトインオブジェクト
            - プログラムの実行時に自動的に実行環境に応じて変換されるオブジェクト
              - グローバルスコープから参照する事ができる
        - グローバル変数
          - グローバルスコープ内で定義した変数
            - どこからでも参照する事ができる
        - 変数の隠蔽
          - ビルドインオブジェクトはグローバルスコープにおいて自動的にその環境によって変換される
            - グローバル変数において万が一、ビルドインオブジェクトと同名の変数が定義された場合には JS の特徴として変数は当該スコープから外側に徐々に検索をかけるため、ビルドインオブジェクトが使えなくなってしまう可能性がある
              - また、ビルドインオブジェクトを避けて変数の定義を行う事は難しい＝＞環境に応じて定義名が違うため
                - グローバル変数は定義しない事が薦められ、定義する場合には変数を関数に切り出すなどとして影響範囲を制限する事が重要と考えられる
      - 変数の影響範囲を小さくする
        - 変数の影響範囲
          - プログラム直下に変数を置いてしまうとグローバル変数となってしまい予期せぬ挙動がその他のコードを記述した際に起きてしまう。
            - グローバル変数の定義は基本さけて関数の中に切り出して定義する事が勧められる
          - 例：処理の実行時間を測定する関数
            - 関数の切り出しなどを意識せずにプログラムする例
              ```JavaScript
              function doHeavyTask() {
                  // 計測したい処理
              }
              const startTime = Date.now();
              doHeavyTask();
              const endTime = Date.now();
              console.log(`実行時間は${endTime - startTime}ミリ秒`);
              ```
              - このプログラムだとグローバル変数が 2 個定義されてしまっている
                - そのためこのグローバル変数を関数に切り出して影響範囲を小さくする
            - 処理時間を継続する関数を作成して影響範囲を小さくする例
              - 計測したい処理をコールバック関数として引数に渡す事で処理を実行する（doHeavyTask）
              ```JavaScript
              // 実行時間を計測したい関数をコールバック関数として引数に渡す
              const measureTask = (taskFn) => {
                  const startTime = Date.now();
                  taskFn();
                  const endTime = Date.now();
                  console.log(`実行時間は${endTime - startTime}ミリ秒`);
              };
              function doHeavyTask() {
                  // 計測したい処理
              }
              measureTask(doHeavyTask);
              ```
              - このようにすると定義されているグローバル変数は 0 になる
                - このように特定の処理がある場合、変数を関数内に切り出す事で影響範囲の限定をする事ができる
    - let や const などの変数定義
      - let や const は再代入禁止の変数となっており、同名の変数を複数回定義する事はできない
        - しかし、これはスコープの範囲内における定義になっている
          - すなわち、スコープが分かれている場合にはこの定義の制限はなくなるという事になる
        - 再代入禁止
          - プロパティを介してアクセスする事で値を変更する事は可能になっているため値の変更ができないわけではないという点に注意が必要
            - しかし、Object.freeze というメソッドを使う事で該当のオブジェクトの１階層目を完全に凍結する事ができる。
    - var の巻き上げという仕様
      - 変数を定義する var は改善された let がすでに存在するため現代では使われる事がなくなった
        - しかし、コードの中には var というコードが存在する可能性がある
          - そのため var という変数の宣言がどのような挙動を起こすのかについて理解する事は重要な事であると言える
      - var による巻き上げ(hosting)
        - var や let を変数の定義前に呼び出すと挙動が同じにならない
          - let => 構文エラーが起こる
          - var => undefind になる
            - これは巻き上げによるものと言える
        - 変数の宣言と代入という概念
          - 変数の宣言
            - 変数を宣言すると let はその場で宣言するが、var は宣言によって巻き上げが起こる
              - 巻き上げを起こすとブロックスコープさえも無視して評価値を決定する事になる
          - 変数の代入
            - 変数の宣言と代入が同位置で起こるのが let であり、var は変数の宣言は巻き上げられて、代入部分はその場に残る
    - 関数の宣言と巻き上げ
      - 関数宣言によって関数を定義する事ができる
        - 関数宣言は宣言そのものであると考える事ができ関数宣言を行った時にその宣言はスコープの先頭に巻き上げられる
          - function キーワードでも同様になる
            - しかし、var で変数に定義した関数のこの通りにはならない
              - var のルールに沿って動作する
    - IIFE(即時実行関数)というイディオム
      - 即時実行関数はこの関数宣言がグローバルスコープを汚染してしまうという問題点から出てきたイディオムになっている
        - 無名関数を宣言してその後、実行まで行う( (function(){}) ();)
          - この無名関数内で宣言した関数は無名関数内で参照され、無名関数外からはアクセスできなくなる
          ```JavaScript
          function fn() {
              var foo = "foo";
              console.log(foo); // => "foo"
          }
          fn();
          // foo変数のスコープ外
          console.log(typeof foo === "undefined"); // => true
          ```
        - IIFE は ECMAScript5 までは var によるグローバルスコープの汚染を防ぐために使われていた
          - 現在は const let が存在するため function などの関数宣言に対して使われる
            - 記載の方法は２通りある
    - クロージャーという概念
      - 静的スコープ
        - 識別子は参照する変数を静的に決定する
          - 変数の参照先は識別子を定義した瞬間に決定されている
            - 呼び出し元の外に変数の参照先がある
      - 動的スコープ
        - 識別子は参照する変数を動的に決定する
          - 変数の参照先は呼び出し元によって変更される
            - 呼び出し元のスコープに存在する変数を参照する
              - this という例外も存在する
      - メモリ管理（ガベレージコレクション）をスコープという面から見る
        - メモリは変数が参照されない事が決定された際に自動的にメモリから解放される仕組みになっている
          - 関数の実行前や実行後などはメモリ管理には関係なく変数が 1 つでも参照されている場合にはメモリ解放されない
      - 結局、クロージャーとは何なのか？
        - クロージャーとは
          - 静的スコープ
            - 変数が何を参照するかは静的に決定される
          - メモリ管理
            - 参照されていない変数は自動的に解放さる
          - この仕組みを使って関数内から特定の関数を参照し続ける事で状態を持ち続ける事ができる「参照され続けている変数のデータが保持される」という事になる
      - クロージャーの用途
        - 関数に状態を持たせる手段として
        - 外から参照できない変数を定義する手段として
        - グローバル変数を減らす手段として
        - 高階関数の一部分として
          - これらの用途がある事でグローバル変数への汚染を防ぐ、高階関数において後から条件を追加するなえどという事ができる
  - this(特殊な動きをする ECMAScript のキーワード)
    - this はコンテキストによって意味が変わる
      - 動的に意味が決定される場合
        - 実行コンテキストにおける this
          - JS の実行コンテキストとして"Script"と"Module"がありその実行コンテクストによって this の評価が変わる
            - そして、実行環境によって評価値が変わってしまうためトップレベルで this は使わない
              - Script の場合
                - グローバルオブジェクトを参照する
                  - ブラウザ=>Window オブジェクト
                  - Node.js=>Global オブジェクト
              - Module の場合
                - モジュールにおいて記載された this は常に undifind になる
                  - このようにトップレベルにおいた this は undifind になる可能性がある
            - Global オブジェクトを参照したい場合
              - globalThis を使って参照するようにする
        - 関数とメソッドにおける this
          - 実行時に値が決まる this となる
            - 関数に暗黙的に渡される this となる
              - なので関数の実行時に値が決定されるという事になる
          - 関数において this を使った時の参照先は基本的にはベースオブジェクトという事になる
            - メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト
              - ベースオブジェクトが存在しない場合には undefind になる
          - メソッドにおいて this を使った場合
            - メソッドは何らかのオブジェクトに属しているため属している元のオブジェクトがベースオブジェクトになる
              - メソッドの中から同じオブジェクトに所属する別のプロパティを this で参照できる
      - 静的に意味が決定される場合
        - Arrow Function における this
          - Arrow Function における this は静的に値が決定される
            - this を暗黙的な引数として受け取らないという特徴があるため
              - 現在のスコープに this の参照先がない場合にはスコープチェーンのように外側のスコープへ this の参照先を探しに行く
                - なので Arrow Funcution に 1 番近い外側のスコープが this の参照先になるという事になる
                  - メソッドの場合には一時的に変数に代入するなどの回避措置を取る必要があったが、Arrow Function の場合には必要なくなる
                    - 代償として各メソッドを使う事ができないという欠点のみ存在するため注意が必要
      - this を使う際に問題になる点
        - メソッドとして定義したものが関数として呼び出されてしまう場合
          - 静的に決定されない特性を this は持つためベースオブジェクトが変わってしまう
            - エラーが投げられてしまう
          - 対処法
            - そもそも、メソッドとして定義しているものはメソッドとして呼ぶ
            - this の値を指定して関数を呼べるメソッドで関数を呼ぶ
              - call、apply、bind メソッド
                - this を明示的に指定して関数を実行する
                  - call
                    - 第一引数に this としたい値を指定し、残りの引数には呼び出す関数の引数を指定する
                      - 通常、暗黙的に渡されている this の値を明示的に渡す
                  - apply
                    - 第一引数に this とする値を指定し、第二引数に関数の引数を配列として渡す
                      - 第二引数に指定した配列は自動的に展開される
                        - call メソッドと apply メソッドは大きく変わらないが、引数の形が違う
                  - bind
                    - this の値を束縛して新しい配列を作る
                - これらのメソッドを活用する事でメソッドとして定義したものも関数として呼び出す事ができる
                  - しかし、毎回のコードを組む手間などを考慮してメソッドはメソッドとして呼ぶというルールを作る事が望ましい
        - コールバック関数の中で this を参照する場合
          - コールバック関数の内部で this を参照してしまうとコールバック関数ではその場で無名関数を呼び出している事になるので undefind となってしまう
            - 一度、callback 関数などに代入しても結果は変わらない
          - 対処法
            - 一時的に変数へ代入して this の参照先を保つ方法
              - 一時的に変数へ保存した上でコールバック関数では一時的に代入した変数を参照する事で this の参照先を保持する方法
                - このように this が動的に意味が変わってしまうという点があるため Arrow Function が用意された
            - Arrow Function でコールバック関数を扱う
              - Arrow Function は関数とは違い暗黙的に this の値を受け取らないため常に外側のスコープへオブジェクトを探しにいく
                - Arrow Function において this を使うと簡潔的に記載する事が可能になる
  - JS におけるメソッド
    - 関数とメソッドの違い
      - 関数
        - メソッドを含めた関数宣言全体の事である
      - メソッド
        - 関数においてプロパティに関数を定義した関数の事をメソッドと呼ぶ
          - プロパティである関数
            - 短縮記法
              - メソッド名(){ /_メソッドの処理_/ }
                - 呼び出し方=>オブジェクト.メソッド名

JavaScript primer - 関数とスコープ - スコープという変数などを参照できる範囲を決める概念を紹介します。ブロックスコープや関数スコープなどがどのような働きをしているのか、複数のスコープが重なったときにどのように変数の参照先が決まるのかなどを紹介します。また、スコープに関係する動作としてクロージャーという性質を紹介します。

        **まとめ**

        - スコープ
            - 関数
            - ブロック
            - ネスト可能
            - 1番大きなスコープ
                - グローバルスコープ
                    - 元々、大きなスコープで囲まれている
            - スコープチェーン
                - 内側のブロックチェーンから外側へ変数の定義を探していく流れの事
                - var,functionでは巻き上げが生じる
        - クロージャー
            - 静的スコープ
            - メモリ管理
    - 関数とthis
        - JavaScriptにおけるthisというキーワードの動作を紹介します。thisの参照先は条件によって解決方法が異なるため、thisの動きについてをそれぞれの条件ごとに紹介します。一見複雑なthisの動きを予測可能にするにはどうするべきかをコード例とともに紹介します。

        **まとめ**

        - this
            - 実際にthisを実行した結果の確認
                - [What is `this` value in JavaScript](https://azu.github.io/what-is-this/)で実行する事ができる
            - thisは実行環境やコンテキストによって結果が変わる可能性があり、メソッドでないものには使うべきではない
    - クラス
        - JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。

        **まとめ**

        - プロトタイプベース
        - クラスの定義
            - クラス構文で定義する
                - プロトタイプオブジェクト
                - プロトタイプチェーン
                    - の２通りで呼び出せる
            - クラスのインスタンスにはクラスフィールドが利用可能
            - Privateクラスフフィールドを使ってアクセルを制限する事が可能
        - アクセッサプロパティはgetter,setterのメソッドでプロパティのように振る舞う
        - extendsでクラスの継承が可能
        - プロトタイプメソッドと静的メソッドはどちらも継承される
    - 例外処理
        - JavaScriptにおける例外処理について紹介します。try...catch構文の使い方やErrorオブジェクトを紹介します。またエラーが発生した際のエラー文の読み方といったデバッグ方法を紹介します。

        **まとめ**

        - try…chtch構文
            - ブロック内で発生した例外を処理する事が可能になる
            - `catch`節と`finally`節は、両方またはどちらか片方を記述する
            - `throw`文は例外を投げることができ、`Error`オブジェクトを例外として投げる
            - `Error`オブジェクトには、ECMAScript仕様や実行環境で定義されたビルトインエラーがある
            - `Error`オブジェクトには、スタックトレースが記録され、デバッグに役立てられる
        - Error Causeを使うことで、別のエラーのスタックトレースを引き継いだ新しいエラーを作成できる
    - 非同期処理:コールバック/Promise/Async Function
        - 同期処理と非同期処理の違い
            - なぜ非同期処理が重要か？
                - 非同期処理を行う方法
                    - コールバックスタイル
                    - Promise
                    - Async Function
        - 非同期処理
            - 非同期処理
                - その処理が終わる前に次の処理を評価する
                    - メインスレッドで実行でされる事もある
            - Promise
                - ES2015で導入されたビルドインプロジェクト
            - Async Function
                - 2017から導入されたビルトインオブジェクト
                    - Promiseの上に作られた構文
                        - Promiseと一緒に使う
    - Map/Set
        - データの集合を扱うビルトインオブジェクト
            - Map
            - Set
                - オブジェクトの作成方法、更新方法
                    - 実際にどのようなケースで使うのかを紹介します。

        **まとめ**

        - Map
            - キーと値の組み合わせからなるコレクションを扱うビルトインオブジェクト
                - 意図しないマッピングを避けられる
        - WeakMap
            - キーを弱い参照で持つMapと同様のビルとインオブジェクト
        - Set
            - 順序を持たないコレクションをもつビルトインオブジェクト
                - 重複する値がない事が保証されている
            - Weakset
                - 値を弱い参照で持つSetと同様のビルトインオブジェクト
    - JSON
        - JavaScriptのオブジェクトリテラルをベースに作られたデータフォーマット
            - JavaScriptからJSONの読み書きをするビルトインオブジェクトの使い方を紹介します。

        **まとめ**

        - JSのオブジェクトリテラル{}を元に作られた軽量なデータフォーマット
            - シリアライズ
                - JSONの中にはシリアライズ不可なオブジェクトもある
                    - JSON.stringifyはシリアライズ対象のtoJsonメソッドを利用する
            - デシリアライズ
    - Date
        - 日付や時刻を扱うビルトインオブジェクトのDateを紹介します。

        **まとめ**

        - Dateオブジェクトのインスタンス
            - 特定の時刻を表すビルトインオブジェクト
        - 時刻の定義
            - UTC（協定世界時）の1970年1月1日0時0分0秒を基準
                - 相対的なミリ秒として保持されている
        - DateコンストラクタでDateインスタンスを作成する事ができる
        - 単体だとユースケースでは使う事が難しい
            - ライブラリと一緒に使う事が一般的
    - Math
        - 数学的な定数や関数を提供するビルトインオブジェクト

        **まとめ**

        - Mathはコンストラクタではない
            - インスタンス化する事ができない
    - ECMAScript
        - JavaScriptの仕様であるECMAScriptについて
            - ECMAScriptの歴史や仕様策定がどのようなプロセスで行われているかを紹介します。

        まとめ

        - JS
            - ECMAScript
            - ウェブブラウザ
            - Node.js
            - WebAssembly
            - WebGL
            - WebRTC
                - 全てを知る事は難しいため知らなくてOK
                    - ただ、過程があるという事
                    - 疑問を持った時には調べる事ができるようになる事が重要
        - ECMAScriptモジュール
        JavaScriptのモジュール（ECMAScriptモジュール）について紹介します。
    - 第一部: 終わりに
        - 第2部でやる事：
            - 1部で学んだ基本文法を使ってアプリケーションを作成する
            - ブラウザ固有のAPI、ライブラリを見る
        - 文法
            - Proxy、Reflect
                - プロパティの取得、代入に対して独自の動作を定義する事ができる
        - 調べ方
            - APIについて
                - MDN Web Docsというリファレンスに大部分が載っている
                    - 実質的な公式レファレンス

- 第 2 部
  - アプリケーション開発の準備
    - Node.js の LTS 版をインストールした
    - npm と npx でモジュールのインストールと実行をした
    - `@js-primer/local-server`モジュールを使ってローカルサーバーを起動して終了した
  - Ajax 通信
    - エントリーポイントの作成
      - このセクションでは、エントリーポイントとなる HTML を作成
        - JavaScript モジュールのエントリーポイントとなる JavaScript ファイルを読み込む
      - `ajaxapp`という名前のプロジェクトディレクトリを作成した
      - エントリーポイントとなる`index.html`を作成した
      - JavaScript のエントリーポイントとなる`index.js`を作成し`index.html`から読み込んだ
      - ローカルサーバーを使ってブラウザで`index.html`を表示した
      - `index.js`からコンソールに出力されたログを確認した
      - JavaScript から HTML ドキュメントを操作する DOM について学んだ
    - HTTP
      - [Fetch API](https://developer.mozilla.org/ja/docs/Web/API/Fetch_API)を使って HTTP リクエストを送った
      - GitHub の API から取得したユーザー情報の JSON オブジェクトをコンソールに出力した
      - Fetch API の呼び出しに対するエラーハンドリングを行った
      - `fetchUserInfo`関数を宣言し、ボタンのクリックイベントで呼び出した
    - データを表示する
      - [テンプレートリテラル](https://jsprimer.net/basic/string/#create)を使って HTML 文字列を組み立てた
      - `innerHTML`プロパティを使って HTML 文字列を DOM に追加した
      - [タグつきテンプレート関数](https://jsprimer.net/basic/string/#tagged-template-function)を使って HTML 文字列をエスケープした
      - `fetchUserInfo`関数を呼び出し、HTML にユーザー情報が表示されることを確認した
    - Promise を活用する
      - HTML の組み立てと表示の処理を`createView`関数と`displayView`関数に分離した
      - `main`関数を宣言し、`fetchUserInfo`関数が返す Promise のエラーハンドリングを行った
      - Promise チェーンを使って`fetchUserInfo`関数をリファクタリングした
      - [Async Function](https://jsprimer.net/basic/async/#async-function)  を使って`main`関数をリファクタリングした
      - `index.html`に`<input>`タグを追加し、`getUserId`関数でユーザー ID を取得した
  - Node.js で CLI ツールを作成する
    - Hello world
      - `nodecli`ディレクトリを作成した
      - `nodecli/main.js`ファイルを作成した
      - `node`コマンドで`nodecli/main.js`を実行し、標準出力にログが出力されるのを確認した
      - `npm init --yes`コマンドで`nodecli/package.json`ファイルを作成した
      - グローバルオブジェクトについて、ウェブブラウザと Node.js で実行環境による違いがあることを理解した
    - コマンドライン引数を設定する
      - `process.argv`配列に`node`コマンドのコマンドライン引数が格納されていることを確認した
      - ECMAScript モジュールを使ってパッケージを読み込めることを確認した
      - `node:util`モジュールの`parseArgs`関数を使ってコマンドライン引数をパースできることを確認した
      - コマンドライン引数で渡されたファイルパスを取得してコンソールに出力できた
    - ファイルを読み込む
      - `node:fs/promises`モジュールの`readFile`関数を使ってファイルを読み込んだ
      - UTF-8 形式のファイルの中身をコンソールに出力した
      - `readFile`関数の呼び出しにエラーハンドリング処理を記述した
    - MarkDown ファイルを HTML へ変換する
      - marked パッケージを使って Markdown 文字列を HTML 文字列に変換した
      - コマンドライン引数で marked の変換オプションを設定した
      - `-gfm`フラグを使って、Markdown の変換結果が変わることを確認した
    - ユニットテストを記述する
      - Markdown の変換処理を ECMAScript モジュールとして`md2html.js`に切り出し、`main.js`から読み込んだ
      - `npm test`コマンドで`node --test`が実行できることを確認した
      - `md2html`関数のユニットテストを作成し、テストの実行結果を確認した
  - Todo アプリケーションを作る
    - エントリーポイント
      - `todoapp`という名前のプロジェクトディレクトリを作成した
      - エントリーポイントとなる`index.html`を作成した
      - JavaScript のエントリーポイントとなる`index.js`を作成し`index.html`から読み込んだ
      - ローカルサーバーを使って`index.html`を表示した
      - `src/App.js`を作成し、`index.js`から`import`文で読み込めるのを確認した
    - アプリケーションの構成要素
      - 実装する Todo アプリの構成要素を理解した
      - HTML、CSS、JavaScript の役割の違いを理解した
      - Todo アプリの見た目を HTML と CSS で定義した
    - Todo アイテムの追加を実装する
      チェクリスト
      - フォームの送信を`submit`イベントで受け取り、入力内容を確認した
      - HTML 文字列から HTML 要素を作成する`html-util.js`を実装した
      - フォームから Todo アイテムを追加した
      - Todo アイテムの追加に合わせて Todo アイテム数を更新した
      このセクションで、Todo アプリに Todo アイテムを追加する機能が実装できました。
      - Todo アイテムを追加できる
      Todo アプリに実装する残りの機能は次のとおりです。
      - Todo アイテムの完了状態を更新できる
      - Todo アイテムを削除できる
    - イベントとモデル
      - 直接 DOM を更新する問題について理解した
      - `EventEmitter`クラスでイベントの仕組みを実装した
      - Todo リストと Todo アイテムをモデルとして実装した
      - `TodoListModel`を`EventEmitter`クラスを継承して実装した
      - Todo アイテムの追加の機能をモデルを使ってリファクタリングした
    - Todo アイテムの更新と削除を実装する
      - Todo アイテムの完了状態として`<input type="checkbox">`を表示に追加した
      - チェックボックスが更新されたときの`change`イベントのリスナー関数で Todo アイテムを更新した
      - Todo アイテムを削除するボタンとして`<button class="delete">x</button>`を表示に追加した
      - 削除ボタンの`click`イベントのリスナー関数で Todo アイテムを削除した
      - Todo アイテムの追加、更新、削除の機能が動作するのを確認した
      このセクションで Todo アプリに必要な要件が実装できました。
      - Todo アイテムを追加できる
      - Todo アイテムの完了状態を更新できる
      - Todo アイテムを削除できる
    - Todo アプリケーションのリファクタリング
      - App から表示に関する処理を View コンポーネントに分割した
      - Todo アプリの機能と対応するリスナー関数を`App`クラスのメソッドへ移動した
      - Todo アプリを完成させた
  - この Todo アプリケーションで実装できていない事
    - 空の投稿を防ぐ事
    - ライフサイクル処理
      - on 関数関連
  - アプリケーションのまとめ
    - JS で作られる代表的なアプリケーションとして Todo アプリがある
      - 今回はライブラリを使用しない
        - 実務では確実にライブラリを使う
          - しかし、ライブラリも基礎の上に立つものである事を忘れないようにする
