(GitHub トークンの流出によって起きた API 改ざん)[https://zenn.dev/omakase/articles/validator-security-incident-2025]

**トークンの流出例(トークンの流出原因不明)**

- 攻撃のざっくりとした経路 => 盗まれた Token → CI/CD の悪用 → 本番環境への侵入

  - トークンの流出

    - 詳細な流出したトークンの情報については非公開 -　トークンといっても様々な種類があるため、どのようなトークンが流出したのか考察が必要

  - CI 実行の悪用

    - Branch の作成や削除によって実行される作業フローを Branch の作成 => すぐに削除 という操作を行う事で実行し大量のファイルを変更し、変更箇所の隠蔽を行う
      - この操作を IaC が管理されているリポジトリで行い CI 環境を悪用した。

  - 秘密情報の取得

    - CI 環境を変更する事で AWS や Google Coloud などの API キーの情報を取得し、本番環境のサーバーへの侵入も実現している

  - K8s への侵入

    - 本番環境の API サーバーが稼働しているクラスタに侵入し API ロジックの改ざんを行う
      - 高度な改ざん方法：改ざんした場合に発見される可能性を低くしている
        - 直接ファイルやコンテナのイメージを書き換える
          - 実際に書き換える事で差分が生じるため、発見の可能性がある
        - 悪意のあるペイロードを注入する
          - ペイロードを注入する事で実行中のコンテンア内で悪意のあるプロセスを実行し iptables(”カーネルレベルのファイアウォール機能で Linux の機能、K8s 上ではパケットのフィルタリングやルーティング等をカーネルレベルで制御する”)や eBPF(サウンドボックス的な機能)を使い、ネットワークトラフィックをリダイレクトしてレスポンスの改ざんを行う
            - 前述のようにファイルやコンテナイメージなどを書き換えないため、発見されるリスクが少なくなる

  - 署名
    - ユーザー側において、API が改ざんされている事はわからず、署名を行なってしまった事で攻撃者へ権限の情報を与えてしまい、資産流出という事になった
      - 余談；本来であれば、トランザクションをデコードしてから署名を行う事が推奨されていたとの事...

- これらの事例からエンジニア再度が学んでおくべき事項

  - GitHub Token の種別

    - 種別一覧

      - Personal Access Token (classic) - Prefix: `ghp_`

        - 今回の事案で流出した Token として最も可能性が高い。無期限設定可能で権限範囲が広い
          - 詳細情報
            - 従来型の Token
              - 組織全体への権限やユーザーの持つリポジトリ単位で権限が与えられる可能性がある
            - Token の有効期限
              - 無期限の設定が可能だが、現在は非推奨となっている
            - 漏洩時のリスク
              - 非常に高い。トークンに与えられたスコープによってはほぼ全ての操作が可能

      - Fine-grained Personal Access Token - Prefix: `github_pat_`

        - Repository 単位で権限制御可能、有効期限必須(最大 1 年)
          - 詳細情報
            - 導入時期
              - 2022 年に導入された新しいトークン
            - セキュリティ強化
              - 有効期限の設定が必須（最大 1 年）
              - Repository 単位で権限を細かく制御可能
              - 最小権限の原則に基づいた運用が可能
            - 漏洩時のリスク
              - classic PAT より限定的だが、必要な Repository と権限が付与されていれば同様の攻撃が可能

      - OAuth App の Access Token - Prefix: `gho_`

        - 外部 SaaS/ツールがユーザー代理で操作
          - 詳細情報
            - 用途
              - 外部の SaaS やツールが、ユーザーの代わりに GitHub を操作するために使用
            - 有効期限
              - 通常は有効期限あり（リフレッシュ可能）
            - 漏洩時のリスク
              - アプリケーションに許可された範囲に限られるが、CI/CD 関連の権限があれば同様の攻撃が可能

      - GitHub App User OAuth Token - Prefix: `ghu_`

        - App 認可時に発行、短命(8 時間)
          - 詳細情報
            - 発行タイミング
              - ユーザーが GitHub App を認可した際に発行される、ユーザーに紐づくトークン
            - 有効期限
              - 短命（8 時間）、リフレッシュ可能
            - 漏洩時のリスク
              - App に許可された Repository と権限に限定される

      - GitHub App Install Access Token - Prefix: `ghs_`

        - App インストール時に発行、最短命(最大 1 時間)
          - 詳細情報
            - 発行タイミング
              - GitHub App が特定の Repository にインストールされた際に発行される、App 自身に紐づくトークン
            - 有効期限
              - 最短命（最大 1 時間）
            - 漏洩時のリスク
              - App に許可された Repository と権限に限定される

      - GITHUB_TOKEN - Prefix なし
        - Actions 実行時に自動発行、ジョブ終了まで有効(今回の攻撃には不向き)
          - 詳細情報
            - 発行タイミング
              - GitHub Actions のワークフロー実行中に自動で発行される
            - 有効期限
              - ジョブ終了までと非常に短い
            - 権限範囲
              - その Repository 内に限定
            - 今回の攻撃での可能性
              - 長期間にわたる外部からの侵入には使いにくく、可能性は低い

  - Token の漏洩するパターン

    - 大前提として今回の事案は Private Repository でおきている

      - Private Repository の安全性について
        - 非公開のリポジトリであってもセキュリティに関する意識は持っておく事が重要になる
          - Token が漏洩した場合にはいかに Private Repository だったとしても Public と同じレベルでのアクセスが可能になってしまう

    - Token が漏洩する 8 つのパターン

      - 1.誤コミット/README や設定ファイルへの混入

        - うっかり Token をコードに書いて git push

      - 2.CI/CD のログ・アーティファクトからの漏洩

        - デバッグログやビルド成果物に Token が含まれる

      - 3.Actions の権限/トリガー設計の不備

        - Pull Request を無条件に信頼、強力なトリガーを安易に使用

      - 4.セルフホスト Runner の隔離不備

        - 環境が共有され、別ジョブの Token が盗まれる

      - 5.端末側の侵害

        - マルウェア感染によりクリップボードやブラウザ情報から漏洩（今回の可能性も）

      - 6.サードパーティ連携の侵害

        - 外部 SaaS/ツールのセキュリティが甘い、Webhook 署名検証の欠如

      - 7.コンテナ/イメージ/キャッシュ層に残置

        - ビルドキャッシュに Token が残り再利用時に露出

      - 8.チケット/チャット/スクリーンショット共有
        - Issue や Slack への貼り付け、画面キャプチャでの流出

  - Token 漏洩を防ぐための予防対策(多層防御)

    - 目的

      - Token や API キーなどの秘匿情報が、"100％"漏洩しないようにするための最初の予防線

    - 1.誤コミット/README・設定混入対策

      - Secret scanning と Push protection を有効化する
        - GitHub が提供している機能で、プッシュされたコードをスキャンし秘匿情報らしき情報(API キーなど)のような文字列があった場合に、警告・ブロックしてくれる
      - .gitignore と pre-commit フックの活用
        - 秘匿情報を Git 管理対象に含めないように.gitignore を正しく設定する事
          - gitleaks のようなツールを pre-commit フックに仕込み、コミット前にローカルで検知・ブロックする
      - 環境変数ファイルの管理
        - .env ファイルは Git で管理しない
          - 必要に応じて暗号化して保管
            - 本番環境では環境変数を直接設定するか、dotenvx のようなツールで安全に管理

    - 2.CI/CD ログ・アーティファクト対策

      - ログに秘匿情報を出力しない工夫をする
        - GitHub Actions の `::add-mask::` コマンドを活用する事で特定の文字列をマスクする事ができる
          - Token、パスワード、API キーは絶対にログへ出力しない
            - `set -x` のようなコマンドは意図せずに環境変数を展開してしまう可能性があるため本番ワークフローで使用禁止にする
      - アーティファクトとキャッシュは最小限にする
        - ビルド成果物やキャッシュには本当に必要なものだけを含める
          - 秘匿情報が含まれていないことを確認してから保存
            - 保持期間を短く設定（retention-days）し、使用後は速やかに削除するように運用する

    - 3.Actions 権限/トリガー不備対策（Public Repository の場合）

      - 外部からの Pull Request は手動承認を必須にする
        - Organization 設定で、フォークされた Repository からの PR は自動実行しないようにする
          - 必ずレビュワーの承認を必須にする悪意のある PR による Secrets 盗難リスクを大幅に削減する事が可能

    - 4.セルフホスト Runner 隔離対策

      - Runner は使い捨て（Ephemeral）で運用
        - ジョブごとに新しい環境を起動し、終了後は破棄する
          - 本番環境デプロイ用 Runner と開発 PR テスト用 Runner は完全に分離
            - ネットワークや権限も分離する

    - 5.端末侵害対策（アクセス制御と基本的なセキュリティ意識）

      - SSO と 2FA（多要素認証）を必須化
        - GitHub ログインはパスワードだけでなく SSO や 2FA を全開発者に強制
          - 認証情報が盗まれた場合でも Token へのアクセスを防ぐ事が可能になる
      - 認証情報を安易に保存しない
        - ブラウザのパスワードマネージャー、クリップボード、SSH エージェントに Token を安易に保存しないようにするなど基本的なセキュリティの意識

    - 6.外部 Action のコミット SHA 固定

      - コミットハッシュを固定する

        - サードパーティ製 Action は `actions/checkout@v4` ではなく `actions/checkout@a12a394...` のようにコミットハッシュで固定
          - タグの上書きによるサプライチェーン攻撃のリスクを予防

      - 設定方法
        - Organization の Settings > Actions > General で設定
        - `Allow Omakase, and select non-Omakase, actions and reusable workflows` を選択
        - `Require actions to be pinned to a full-length commit SHA` にチェック

    - 7.コンテナ/イメージ/キャッシュ層対策

      - ビルド時の秘匿情報管理
        - マルチステージビルドを活用し、最終イメージに秘匿情報を含めない
          - Docker build secrets 機能を使用して、ビルド時のみ必要な情報を安全に渡す
            - ビルドキャッシュに秘匿情報が残らないよう注意

    - 8.チケット/チャット/スクリーンショット対策
      - とにかく貼らない、写さない
        - 秘密情報は絶対にパブリックな場所へ共有しない
          - Issue、Pull Request のコメント、Slack などのチャットツールに Token、パスワード、API キーを貼り付けない
            - スクリーンショットにも秘匿情報が写り込まないよう注意
              - 運用と文化としてルールを徹底

- Token 漏洩時の被害を最小限に抑えるための対策（被害軽減層）

  - 目的

    - 予防策をすり抜けて Token が漏洩してしまった場合に、攻撃者が悪用できる範囲を制限
      - 多層防御の考え方に基づき、被害を最小限に留める

  - 本番に影響を与える CI/CD の経路を限定する

    - 1.Secrets は Environments を利用して分離し、レビュワーの承認を強制する

      - Environments 機能の活用

        - 環境ごと（本番/ステージング等）に Secrets を分離した上で本番環境へのデプロイには信頼できるメンバーの承認を必須化
          - 攻撃者が CI/CD をトリガーできても承認者のチェックを突破できない

      - Environments の真価
        - シークレットへのアクセスに「保護ルール（承認者の必須化）」を強制できる点
          - 環境ごとに異なる値を設定可能（production と staging で異なるクレデンシャル）
            - 被害の範囲をさらに限定的にする事が可能

    - 2.権限最小化（permissions: read をデフォルト設定し、必要時のみ権限昇格）

      - GITHUB_TOKEN の権限設定

        - デフォルトは読み取り専用（permissions: read-all）
          - 特定のジョブで書き込み権限が必要な場合のみ、そのジョブ単位で権限を昇格
            - 例：permissions: contents: write

      - 効果
        - ワークフロー全体が乗っ取られても被害の範囲を限定

    - 3.Repository シークレットに本番情報を置かない

      - Repository Secrets のリスク

        - Token 漏洩時、攻撃者がワークフローを実行して使えてしまう
          - Private Repository でも Token 漏洩時は同じリスク

      - 重要な認識

        - 「Repository Secrets が危険」なのではなく、「保護ルールなしで重要なシークレットが利用できてしまう状態が危険」

      - 対策
        - 本番環境の認証情報のような重要情報は Repository の Secrets に置かない
          - Environments の Secrets に格納して厳格にアクセスを管理
            - 承認者のチェックを突破しない限り本番環境の Secrets にアクセス不可

    - 4.push: branches: [main] などに限定して Secrets を渡す

      - トリガーイベントの制限
        - 本番環境の Secrets を利用できるワークフローは main ブランチへの push など信頼できるイベントのみに限定
          - 開発中のブランチから本番環境の Secrets へ安易にアクセスできないようにする

    - 5..github/workflows/の変更にセキュリティ承認を必須化

      - ワークフローファイル改ざんのリスク

        - ワークフローファイルを書き換えて Secrets を盗み出す攻撃が考えられる
          - 例：Secrets を環境変数として出力させる

      - 対策

        - .github/workflows/ディレクトリ配下のファイル変更には第三者の承認を必須化

          - Pull Request のレビュー段階で攻撃を防ぐ

        - 今回の事件との関係
          - 今回は攻撃者がワークフローファイル自体を改ざんせず、既存のワークフローをトリガーする形で攻撃
            - この対策は直接的な効果がなかったが、別の攻撃シナリオに対して有効
            - 多層防御の一環として導入すべき対策

- yaml ファイルなどの設定例

```yaml

name: Secure Deploy
		on:
			push:
				branches:
					- main # 5. mainブランチへのpushでのみトリガー

		# 2. デフォルトは読み取り権限のみ
		permissions:
			contents: read

		jobs:
			deploy:
				name: Deploy to Production
				runs-on: ubuntu-latest
				# 1. production環境を指定し、承認を強制
				environment:
					name: production
					url: https://example.com

				# OIDCを使うため、id-tokenの書き込み権限をジョブ単位で付与
				permissions:
					id-token: write

				steps:
					- name: Checkout
						# 4. コミットSHAでActionを固定
						uses: actions/checkout@a12a3943b4bde6ff22b8f99495b33c59aed7c3d2

					- name: Deploy to Production
						env:
							# 3. EnvironmentのSecretを利用
							APP_CONFIG: ${{ secrets.APP_CONFIG }}
						run: |
							echo "Deploying to production..."
							# ./deploy.sh
```

      - セキュリティ承認の設定方法
        - CODEOWNERS ファイルの作成
          - Repository のルートに CODEOWNERS ファイルを作成
          - `/.github/workflows/ @organization/security-team` のように記述
        - ブランチ保護ルールの設定
          - Settings > Branches で main ブランチの保護ルールを開く
          - `Require a pull request before merging` と `Require review from Code Owners` を有効化

    - 6.長期シークレットの撤廃（OIDC の活用）

      - 長期シークレットのリスク

        - PAT（Personal Access Token）やクラウドのアクセスキーは一度漏洩すると長期間悪用される
        - 可能な限り有効期限の短い「短期トークン」に置き換える

      - OIDC（OpenID Connect）連携のメリット

        - クラウドの長期的なアクセスキーを GitHub の Secrets に保存する必要がなくなる
        - ワークフロー実行ごとに有効期限の短い一時的な認証情報が発行される
        - 現代の CI/CD セキュリティにおいて最重要対策の一つ

      - 重要なポイント

        - OIDC 連携で作成する IAM Role に最小限の権限のみを付与
        - 攻撃者がトークンを入手しても実行できる操作を厳しく制限

      - AWS との OIDC 連携例
        - `permissions: id-token: write` を設定（OIDC に必須）
        - `aws-actions/configure-aws-credentials@v4` を使用
        - 事前に AWS で作成した IAM Role を指定

    - 7.サードパーティ連携のセキュリティ強化

      - OAuth/GitHub App のベストプラクティス遵守
        - PKCE フローの利用
        - リダイレクト URI の厳格な固定
        - Webhook の署名検証
        - 外部ツール経由での Token 漏洩リスクを低減

    - 8.コンテナイメージへの秘匿情報残置対策

      - リスク

        - Token がコンテナイメージのレイヤーに残ると、イメージを入手した攻撃者に漏洩

      - 対策
        - マルチステージビルドの活用
        - 最終的なイメージに不要なビルド時の情報が残らないようにする
        - `--mount=type=secret` オプションの使用
        - ビルド時に Token が必要な場合、イメージレイヤーに Token が残るのを防ぐ

    - 9.秘匿情報漏洩時のローテーション手順の確立

      - 事前に迅速な対応手順を確立しておく
        - 漏洩を発見した時点でチーム全体に通知
        - 漏洩した Token/キーを即座に無効化
        - 新しい Token/キーを発行
        - すべての環境で新しい認証情報に置き換え
        - ログを確認して悪用状況を調査

- Token 漏洩の早期検知と迅速な対応（検知・対応層）

  - 目的

    - Token 漏洩が発生した場合に早期に検知し、迅速に対応
    - 予防と被害軽減がすり抜けられた場合の最後の砦

  - 1.GitHub 監査ログの常時転送＆検知

    - 異常なアクティビティの早期検知

      - GitHub の監査ログを常時 SIEM ツールや Slack などに転送
      - 監視する仕組みを構築

    - アラート対象とすべきイベント

      - ブランチの作成・削除が短時間に大量発生
      - workflow_dispatch（手動実行）の急増
      - 新しい Runner の登録や削除
      - Secrets の更新
      - Repository の設定変更

    - 効果
      - 今回のケースのような攻撃の兆候を侵入の初期段階で掴める可能性

  - 2.Kubernetes Pod への操作の異常検知

    - 背景

      - GitHub Actions の監視だけでは「デプロイ後の活動」を検知できない
      - Pod 内部での不審な振る舞いを検知する仕組みが重要

    - Falco によるランタイムセキュリティ監視

      - CNCF のインキュベーションプロジェクト
      - コンテナランタイムセキュリティのデファクトスタンダードツール
      - eBPF を用いてカーネルレベルでシステムコールを監視
      - 定義されたルールに違反する不審なアクティビティをリアルタイムで検知

    - 検知する攻撃行動の例

      - シェルを起動する → `Terminal shell in container` ルール
      - 機密ファイルを読み取る → `Read sensitive file untrusted` ルール
      - 外部に不正な通信を行う → `Unexpected outbound connection destination` ルール
      - パッケージをインストールする → `Launch package management process in container` ルール

    - 正当な運用と攻撃の区別方法

      - コンテキスト情報の活用
        - 親プロセス（kubelet 経由か否か）
        - 実行ユーザー（標準ユーザーか root か）
        - 実行時刻（業務時間内か深夜か）
        - ネットワーク接続元（社内ネットワークか外部か）
      - ホワイトリスト化による除外
        - 許可されたオペレーター名をリスト化
        - 営業時間外のシェル起動は常に検知

    - 監視フロー
      - イベント発生 → システムコール監視 → コンテキスト判定 → 異常検知 → アラート通知 → インシデント対応

  - 3.EDR（Endpoint Detection and Response）の導入

    - 目的

      - 開発者のマシンが Token の漏洩源となる可能性への対応
      - マルウェア感染やクリップボード盗聴などの異常を早期に検知

    - 効果
      - 万が一マルウェアに感染しても活動を早期に検知・対応
      - 開発者マシンからの Token 漏洩を早期に発見できる可能性が高まる

  - 4.インシデント対応計画の策定

    - Token 漏洩検知時の対応フローを事前に定義
      - 漏洩検知時の通知先と通知方法
      - 初期対応（Token の無効化、ログ確認）
      - 影響範囲の調査
      - 復旧手順
      - 事後分析とプロセス改善

- まとめ：多層防御の重要性

  - 今回の攻撃の特徴

    - CI/CD パイプラインという「システムの作り方」そのものを悪用
    - ファイルやコンテナイメージを残さない高度な手法
    - iptables や eBPF を使ってネットワークトラフィックをリダイレクトし API レスポンスを改ざん
    - 検知が非常に困難

  - 対策の全体像

    - 予防層（Token を漏洩させない）

      - Secret scanning の有効化
      - pre-commit フックの導入
      - ログへのマスキング
      - 外部 PR の手動承認
      - Runner の分離
      - SSO/2FA の必須化

    - 被害軽減層（漏洩しても大丈夫なようにする）

      - CI/CD の経路を Environment や承認ルールで厳格に管理
      - OIDC を活用して長期シークレットを撤廃
      - 監査ログで異常を監視

    - 検知・対応層（早期発見と迅速な対応）
      - GitHub 監査ログの常時監視
      - Kubernetes ランタイムセキュリティ（Falco）
      - EDR 導入
      - インシデント対応計画

  - 重要な考え方
    - セキュリティに「絶対」はない
    - 1 つの対策に頼るのではなく、複数の防御策を組み合わせる「多層防御」が何よりも重要
    - このインシデントを他人事と捉えず、開発現場でセキュリティ対策を見直すきっかけに
